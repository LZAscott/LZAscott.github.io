<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leoli的博客</title>
  
  <subtitle>越努力，越幸运！！！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-02T12:24:09.619Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Leoli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS包重签名技术知识</title>
    <link href="http://example.com/post/ebb4149f.html"/>
    <id>http://example.com/post/ebb4149f.html</id>
    <published>2023-12-02T11:49:59.000Z</published>
    <updated>2023-12-02T12:24:09.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>利用Xcode的命令<code>security</code>和<code>codesign</code>处理ipa重签。重签名与Xcode打包签名本质上是一个原理，具体流程如下，提前需要准备以下2个文件：</p><table><thead><tr><th>文件名</th><th>备注</th></tr></thead><tbody><tr><td>Provisioning Profile</td><td>描述文件，会像Xcode一样双击安装在电脑上的描述文件，用命令行可以列举出来，可以过滤过期的证书</td></tr><tr><td>Signing Certificate</td><td>选择对应的证书，通用会检索系统钥匙串安装的可用的证书，会自动过滤掉过期的</td></tr></tbody></table><span id="more"></span><h1 id="使用的命令"><a href="#使用的命令" class="headerlink" title="使用的命令"></a>使用的命令</h1><h2 id="添加p12证书"><a href="#添加p12证书" class="headerlink" title="添加p12证书"></a>添加p12证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security import /Users/admin/Desktop/dis.p12 -P &#x27;123456&#x27;</span><br></pre></td></tr></table></figure><h2 id="解压ipa包"><a href="#解压ipa包" class="headerlink" title="解压ipa包"></a>解压ipa包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip yourApp.ipa</span><br><span class="line"></span><br><span class="line">// 查找.app目录，删除系统临时文件</span><br><span class="line">rm -rf ./Payload/yourAppName.app/.DS_Store</span><br></pre></td></tr></table></figure><h2 id="修改Payload-yourName-app中的icon图标、info-plist文件的信息等"><a href="#修改Payload-yourName-app中的icon图标、info-plist文件的信息等" class="headerlink" title="修改Payload&#x2F;yourName.app中的icon图标、info.plist文件的信息等"></a>修改Payload&#x2F;yourName.app中的icon图标、info.plist文件的信息等</h2><p>(如有需要)，比如版本号，应用名称等</p><h2 id="删除之前的签名-CodeSignature"><a href="#删除之前的签名-CodeSignature" class="headerlink" title="删除之前的签名 -&gt; .CodeSignature"></a>删除之前的签名 -&gt; .CodeSignature</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./Payload/yourAppName.app/_CodeSignature</span><br></pre></td></tr></table></figure><h2 id="用授权文件生成entitlements-plist文件"><a href="#用授权文件生成entitlements-plist文件" class="headerlink" title="用授权文件生成entitlements.plist文件"></a>用授权文件生成entitlements.plist文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查看授权文件内容命令</span><br><span class="line">security cms -D -i &quot;xxx.mobileprovision&quot;</span><br><span class="line"></span><br><span class="line">// 输出原来的 Entitlements 配置(可能需要与4.2对比，比如是更新包名的应用，bundle id是变的！)</span><br><span class="line">security cms -D -i embedded.mobileprovision &gt; entitlement_full.plist</span><br><span class="line"></span><br><span class="line">// 只保留 Entitlements 属性内容</span><br><span class="line">/usr/libexec/PlistBuddy -x -c \&#x27;Print:Entitlements\&#x27; entitlement_full.plist &gt; entitlement.plist</span><br></pre></td></tr></table></figure><p><strong>注：本步骤的 Entitlements 属性内容 非常重要，不能多字段，否则重签是有效，但导致ipa包安装失败~</strong></p><h2 id="替换描述文件"><a href="#替换描述文件" class="headerlink" title="替换描述文件"></a>替换描述文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 把新的描述文件复制替换到解压后的目录中。</span><br><span class="line">cp ./embedded.mobileprovision ./Payload/yourAppName.app/embedded.mobileprovision</span><br></pre></td></tr></table></figure><p>如果需要查看系统中已经保存的描述文件：“~&#x2F;Library&#x2F;MobileDevice&#x2F;Provisioning\ Profiles&#x2F;”</p><h2 id="重新签名"><a href="#重新签名" class="headerlink" title="重新签名"></a>重新签名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这一步需要读取你钥匙串中的开发者证书，可以用以下命令查看下有哪些证书：</span><br><span class="line">security find-identity -p codesigning -v</span><br><span class="line"></span><br><span class="line">// 先重签名framework和dylib（不重签的话，就删除无法签名的插件文件：PlugIns文件夹、Watch文件夹）</span><br><span class="line">/usr/bin/codesign --force --sign &quot;iPhone Distribution:xxxxx&quot; --entitlements entitlements.plist /Payload/XX.app/Frameworks/xxx.framework</span><br><span class="line"></span><br><span class="line">// 再签名.app：</span><br><span class="line">$ /usr/bin/codesign -f -s &quot;iPhone Distribution:xxxxx&quot; ./Desktop/Payload/yourAppName.app</span><br><span class="line"></span><br><span class="line">// 成功后提示：</span><br><span class="line">./Payload/yourAppName.app: replacing existing signature.</span><br></pre></td></tr></table></figure><h2 id="压缩Payload，就完成了重签"><a href="#压缩Payload，就完成了重签" class="headerlink" title="压缩Payload，就完成了重签"></a>压缩Payload，就完成了重签</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -ry ABC.ipa Payload</span><br></pre></td></tr></table></figure><h2 id="验证：查看签名信息并在真机上进行安装"><a href="#验证：查看签名信息并在真机上进行安装" class="headerlink" title="验证：查看签名信息并在真机上进行安装"></a>验证：查看签名信息并在真机上进行安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 验证签名正确性：</span><br><span class="line">codesign -v Payload/XX.app</span><br><span class="line"></span><br><span class="line">// 查看app的签名信息:</span><br><span class="line">codesign -vv -d Payload/XX.app</span><br></pre></td></tr></table></figure><h2 id="删除安装的P12证书"><a href="#删除安装的P12证书" class="headerlink" title="删除安装的P12证书"></a>删除安装的P12证书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security delete-certificate -c &quot;iPhone Distribution: xxxxxx&quot;</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 检查一下是否安装了AppleWWDRCA.cer：</span><br><span class="line">security find-certificate -c &quot;Apple Worldwide Developer Relations Certification Authority&quot;</span><br><span class="line"></span><br><span class="line">// 查看app的 entitlements</span><br><span class="line">codesign --entitlements :- -d Payload/yourAppName.app</span><br></pre></td></tr></table></figure><h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ul><li><a href="https://github.com/HanProjectCoder/ResignForiOS">HanProjectCoder&#x2F;ResignForiOS: ipa resign</a></li><li><a href="https://github.com/fastlane/fastlane/tree/master/sigh">fastlane&#x2F;sigh at master · fastlane&#x2F;fastlane</a></li><li><a href="https://github.com/cjsliuj/Scalpel">cjsliuj&#x2F;Scalpel: A MacOS app with resign, dylib link injection&#x2F;delete, ipa metadata edit.</a></li><li><a href="https://blog.csdn.net/jerryandliujie/article/details/84845162">Scalpel的实现：一款集动态库注入与删除、IPA重签名、IPA元数据修改为一体的MacOS App</a></li><li><a href="https://gist.github.com/FredCox3/0617eba0818a3ba957b7">cfgutil man page</a></li><li><a href="https://stackoverflow.com/questions/7485806/install-p12-or-cer-in-console-macos">shell - install .p12 or .cer in console macos - Stack Overflow</a></li><li><a href="https://github.com/hongbaoshi/reSignature/blob/master/reSignature/TFSignature.py">reSignature&#x2F;TFSignature.py at master · hongbaoshi&#x2F;reSignature</a></li><li><a href="https://www.jianshu.com/p/ce2893d99bd4">iOS开发中的应用打包方式及重签名的一些总结 - 简书</a></li><li><a href="https://blog.0x5e.cn/2016/09/25/ios-codesign-things/">iOS代码签名与重签名 · 0x5e的博客</a></li><li><a href="https://developer.apple.com/library/archive/technotes/tn2206/_index.html">Technical Note TN2206: macOS Code Signing In Depth</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;利用Xcode的命令&lt;code&gt;security&lt;/code&gt;和&lt;code&gt;codesign&lt;/code&gt;处理ipa重签。重签名与Xcode打包签名本质上是一个原理，具体流程如下，提前需要准备以下2个文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Provisioning Profile&lt;/td&gt;
&lt;td&gt;描述文件，会像Xcode一样双击安装在电脑上的描述文件，用命令行可以列举出来，可以过滤过期的证书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Signing Certificate&lt;/td&gt;
&lt;td&gt;选择对应的证书，通用会检索系统钥匙串安装的可用的证书，会自动过滤掉过期的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="重签名" scheme="http://example.com/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/post/4a17b156.html"/>
    <id>http://example.com/post/4a17b156.html</id>
    <published>2023-12-02T10:21:11.000Z</published>
    <updated>2023-12-02T12:09:54.078Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="博客Blog" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2Blog/"/>
    
    <category term="hexo" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2Blog/hexo/"/>
    
    <category term="new-yilia" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2Blog/new-yilia/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
    <category term="new-yilia" scheme="http://example.com/tags/new-yilia/"/>
    
  </entry>
  
  <entry>
    <title>math</title>
    <link href="http://example.com/post/a927044d.html"/>
    <id>http://example.com/post/a927044d.html</id>
    <published>2023-12-02T10:21:11.000Z</published>
    <updated>2023-12-02T10:27:22.216Z</updated>
    
    <content type="html"><![CDATA[<p>如 $\lim_{x \to 0} \frac{\sin x}{x}$ 渲染的是</p><p>$$<br>\begin{eqnarray}<br> \lim_{x \to 0} \frac{\sin x + x^2 + x^3}{x} &amp; &#x3D; &amp; \lim_{x \to 0} \frac{\sin x }{x} + \lim_{x \to 0} \frac{x^2 }{x} + \lim_{x \to 0}\frac{x^3}{x}<br>\\ &amp; &#x3D; &amp; \lim_{x \to 0}\frac{\sin x}{x}<br>\\ &amp; &#x3D; &amp; 1<br>\end{eqnarray}<br>$$</p><span id="more"></span><p>斐波那契数列$A_n&#x3D;A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例<br>$$\lim_{n\to \infty}\frac{A_{n-1}}{A_n}&#x3D;\frac{\sqrt{5}-1}{2}.$$</p><p>因式分解<br>$$\begin{split}(x−1)(x−3)&amp;&#x3D;x^2−4x+3 \<br>&amp;&#x3D;x^2−4x+4−1 \<br>&amp;&#x3D;(x−2)^2−1<br>\end{split}<br>$$</p><p>狄利克雷函数</p><p>$$<br>D(x)&#x3D;<br>\begin{cases}<br>1,&amp; x \in Q \<br>0,&amp; x \notin Q<br>\end{cases}<br>$$</p><p>高斯公式<br>$$<br>\iiint_{\Omega}\left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) d v&#x3D;\iint_{\Sigma} P d y d z+Q d z d x+R d x d y<br>$$</p><h2 id="物理公式"><a href="#物理公式" class="headerlink" title="物理公式"></a>物理公式</h2><ul><li>牛顿第一定律: $\sum \vec{F}_{i}&#x3D;\frac{\mathrm{d} \vec{v}}{\mathrm{d} t}&#x3D;0$</li><li>牛顿第二定律: $\vec{F}&#x3D;\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \frac{\mathrm{d} \vec{v}}{\mathrm{d} t}&#x3D;\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \vec{a}&#x3D;\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \frac{\mathrm{d}^{2} \vec{r}}{\mathrm{d} t^{2}}$</li><li>牛顿第三定律: $\overrightarrow{F_{12}}&#x3D;-\overrightarrow{F_{21}}$</li><li>质能守恒: $E&#x3D;mc^2$</li></ul><h2 id="化学公式"><a href="#化学公式" class="headerlink" title="化学公式"></a>化学公式</h2><p>离子反应与沉淀: $\ce{SO4^2- + Ba^2+ -&gt; BaSO4 v}$</p><h2 id="生物公式"><a href="#生物公式" class="headerlink" title="生物公式"></a>生物公式</h2><p>光合作用<br>范德蒙行列式<br>$$D_{n-1}&#x3D;\left|\begin{array}{cccc}<br>1 &amp; 1 &amp; \dots &amp; 1 \<br>x_{2} &amp; x_{3} &amp; \dots &amp; x_{n} \<br>\vdots &amp; \vdots &amp; &amp; \vdots \<br>x_{2}^{n-2} &amp; x_{3}^{n-2} &amp; \dots &amp; x_{n}^{n-2}<br>\end{array}\right|&#x3D;\prod_{2 \leq j&lt;i \leq n}\left(x_{i}-x_{j}\right)$$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如 $&#92;lim_{x &#92;to 0} &#92;frac{&#92;sin x}{x}$ 渲染的是&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;&#92;begin{eqnarray}&lt;br&gt; &#92;lim_{x &#92;to 0} &#92;frac{&#92;sin x + x^2 + x^3}{x} &amp;amp; &amp;#x3D; &amp;amp; &#92;lim_{x &#92;to 0} &#92;frac{&#92;sin x }{x} + &#92;lim_{x &#92;to 0} &#92;frac{x^2 }{x} + &#92;lim_{x &#92;to 0}&#92;frac{x^3}{x}&lt;br&gt;&#92;&#92; &amp;amp; &amp;#x3D; &amp;amp; &#92;lim_{x &#92;to 0}&#92;frac{&#92;sin x}{x}&lt;br&gt;&#92;&#92; &amp;amp; &amp;#x3D; &amp;amp; 1&lt;br&gt;&#92;end{eqnarray}&lt;br&gt;$$&lt;/p&gt;</summary>
    
    
    
    <category term="math" scheme="http://example.com/categories/math/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>React Native--环境配置</title>
    <link href="http://example.com/post/41e657ca.html"/>
    <id>http://example.com/post/41e657ca.html</id>
    <published>2016-08-15T08:09:22.000Z</published>
    <updated>2023-12-02T10:27:22.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近学习React Native，做点笔记，也希望能帮到需要的人。</p><span id="more"></span><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><ul><li><strong>定义：</strong>Homebrew是OS X的套件(包)管理器，我们可以通过它获取并且安装很多组件。</li><li><strong>安装方式：</strong>在终端运行<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e <span class="string">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>注意：</strong>执行上面的命令之后，安装过程取决于你当前的网速。</li></ul><h3 id="安装npm和Node-js"><a href="#安装npm和Node-js" class="headerlink" title="安装npm和Node.js"></a>安装npm和Node.js</h3><ul><li>Node.js最好安装<strong>4.0</strong>及其以上更高版本，node安装成功之后npm自动就有了，直接下载安装Node.js，网址：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></li></ul><h3 id="安装WatchMan"><a href="#安装WatchMan" class="headerlink" title="安装WatchMan"></a>安装WatchMan</h3><ul><li><strong>作用：</strong>该插件用于监控bug和文件变化，并且可以触发指定的操作。(非必须安装，看自己意愿)</li><li><strong>安装方式：</strong><code>brew install watchman</code>,当出现🍺图标的时候，表示已经安装成功，由于我电脑已经安装了，所以会提示<code>Warning: watchman-4.5.0 already installed</code></li><li><strong>注意：</strong>在Mac OS X 10.11(EI Capitan)版本中，homebrew在安装软件时可能会碰到&#x2F;usr&#x2F;local目录不可写的权限问题。可以使用在前面添加 <code>sudo</code>(管理员权限)。</li></ul><h3 id="安装Flow"><a href="#安装Flow" class="headerlink" title="安装Flow"></a>安装Flow</h3><ul><li><strong>定义：</strong>flow是一个JavaScript的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误。</li><li><strong>安装方式：</strong><code>brew install flow</code>，同安装WatchMan一样，当出现🍺图标的时候，表示已经安装成功，如果你电脑已经安装了，则会提示<code>Warning: flow-0.24.1 already installed</code></li><li><strong>注意：</strong>如果提示<code>command not found</code>，请加上<code>sudo</code>获取管理员权限。</li></ul><h2 id="React-Native安装"><a href="#React-Native安装" class="headerlink" title="React Native安装"></a>React Native安装</h2><h3 id="安装React-Native"><a href="#安装React-Native" class="headerlink" title="安装React Native"></a>安装React Native</h3><ul><li><strong>安装方式：</strong><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g react-native-cli</span><br></pre></td></tr></table></figure></li></ul><h2 id="React-Native的第一个应用"><a href="#React-Native的第一个应用" class="headerlink" title="React Native的第一个应用"></a>React Native的第一个应用</h2><h3 id="执行命令，生成一个工程"><a href="#执行命令，生成一个工程" class="headerlink" title="执行命令，生成一个工程"></a>执行命令，生成一个工程</h3><ul><li>react-native init 项目名</li></ul><p>等待终端完成。就代表我们的环境已经配置好了。<br><strong>注意：</strong>本文是针对 iOS,因此没有配置 Android环境。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近学习React Native，做点笔记，也希望能帮到需要的人。&lt;/p&gt;</summary>
    
    
    
    <category term="React Native" scheme="http://example.com/categories/React-Native/"/>
    
    
    <category term="React Native" scheme="http://example.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Next主题添加留言本页面</title>
    <link href="http://example.com/post/a893cf31.html"/>
    <id>http://example.com/post/a893cf31.html</id>
    <published>2016-08-13T13:34:24.000Z</published>
    <updated>2023-12-02T10:27:22.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章介绍如何给Next主题添加留言功能。</p><span id="more"></span><h3 id="添加留言本page"><a href="#添加留言本page" class="headerlink" title="添加留言本page"></a>添加留言本page</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page guestbook</span><br></pre></td></tr></table></figure><h3 id="留言本页面"><a href="#留言本页面" class="headerlink" title="留言本页面"></a>留言本页面</h3><p>在上一步使用<code>hexo</code>命令新建了的page页面，添加以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;ds-recent-visitors&quot;</span> data-num-items=<span class="string">&quot;28&quot;</span> data-avatar-size=<span class="string">&quot;42&quot;</span> id=<span class="string">&quot;ds-recent-visitors&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后登陆自己的多说站点，进入设置-&gt;自定义CSS,添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#ds-reset .<span class="property">ds</span>-avatar img,</span><br><span class="line">#ds-recent-visitors .<span class="property">ds</span>-avatar img &#123;</span><br><span class="line">   <span class="attr">width</span>: 54px;</span><br><span class="line">   <span class="attr">height</span>: 54px;     <span class="comment">/*設置圖像的長和寬，這裏要根據自己的評論框情況更改*/</span></span><br><span class="line">   border-<span class="attr">radius</span>: 27px;     <span class="comment">/*設置圖像圓角效果,在這裏我直接設置了超過width/2的像素，即為圓形了*/</span></span><br><span class="line">   -webkit-border-<span class="attr">radius</span>: 27px;     <span class="comment">/*圓角效果：兼容webkit瀏覽器*/</span></span><br><span class="line">   -moz-border-<span class="attr">radius</span>: 27px;</span><br><span class="line">   box-<span class="attr">shadow</span>: inset <span class="number">0</span> -1px <span class="number">0</span> #3333sf;     <span class="comment">/*設置圖像陰影效果*/</span></span><br><span class="line">   -webkit-box-<span class="attr">shadow</span>: inset <span class="number">0</span> -1px <span class="number">0</span> #3333sf;</span><br><span class="line">&#125;</span><br><span class="line">#ds-recent-visitors .<span class="property">ds</span>-avatar &#123;</span><br><span class="line">   <span class="attr">float</span>: left</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*隱藏多說底部版權*/</span></span><br><span class="line">#ds-thread #ds-reset .<span class="property">ds</span>-powered-by &#123;</span><br><span class="line">   <span class="attr">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="菜单设置中添加留言本"><a href="#菜单设置中添加留言本" class="headerlink" title="菜单设置中添加留言本"></a>菜单设置中添加留言本</h3><p>找到<code>NexT</code>主题设置的<code>_config.yml</code>文件里面的<code>menu</code>项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: /</span><br><span class="line"> categories: /categories</span><br><span class="line"> archives: /archives</span><br><span class="line"> tags: /tags</span><br><span class="line"> about: /about</span><br><span class="line"> guestbook: /guestbook</span><br><span class="line"> #commonweal: /404.html</span><br></pre></td></tr></table></figure><h3 id="添加多语言文件的值"><a href="#添加多语言文件的值" class="headerlink" title="添加多语言文件的值"></a>添加多语言文件的值</h3><p>因为这里使用的是中文，找到<code>languages</code>文件夹里面的<code>zh-Hans.yml</code>文件，<code>menu</code>子项中添加留言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: 首页</span><br><span class="line"> archives: 归档</span><br><span class="line"> categories: 分类</span><br><span class="line"> tags: 标签</span><br><span class="line"> about: 关于</span><br><span class="line"> search: 搜索</span><br><span class="line"> commonweal: 公益404</span><br><span class="line"> guestbook: 留言</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章介绍如何给Next主题添加留言功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>如何正确使用const(常量),define(宏)</title>
    <link href="http://example.com/post/5f6a69b3.html"/>
    <id>http://example.com/post/5f6a69b3.html</id>
    <published>2016-06-23T14:47:59.000Z</published>
    <updated>2023-12-02T10:27:22.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，也许我们会经常使用到宏定义，或者用const修饰一些数据类型，经常有开发者不知道怎么正确使用，导致项目中乱用宏定义与const修饰符。本篇主要介绍在开发中怎么正确使用<code>const</code>与<code>define(宏定义)</code></p><span id="more"></span><p>当我们想定义全局共用的一些数据时，比如通知名字，动画时长等等，我们可以用<code>宏</code>、<code>常量</code>、<code>变量</code>：</p><ul><li><p><strong>宏：</strong></p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意后面不需要带符号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ScottDidLoginSuccess @<span class="string">&quot;登陆成功&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>变量：</strong></p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意后面一定要带符号</span></span><br><span class="line"><span class="built_in">NSString</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>；</span><br></pre></td></tr></table></figure></li><li><p><strong>常量：</strong></p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四种写法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>；</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>那么问题来了，我们到底该如何选择呢？<br>让我来先将一下我对它们之间的理解吧：</p><ul><li><strong>宏：</strong>只是在预处理阶段进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化，只保存一份到数据段。甚至有相同后缀的字符串也可以优化，你可以使用GCC编译测试，<code>Hello world</code>与<code>world</code>两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整型、浮点型会有多分拷贝，但这些数写在指令中，占的只是代码片段而且，大量使用宏会导致二进制文件变大。</li><li><strong>变量：</strong>共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以被修改，在编译阶段做类型检查。</li><li><strong>常量：</strong>共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据<code>const</code>修饰的位置设定能够修改，在编译阶段做类型检查。</li></ul><h2 id="常量区分"><a href="#常量区分" class="headerlink" title="常量区分"></a>常量区分</h2><ul><li><p><strong>全局常量：</strong>不管你定义在任何文件夹，外部都能访问</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>局部常量：</strong>用static修饰后，不能供外界访问</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="const修饰位置不同，代表什么"><a href="#const修饰位置不同，代表什么" class="headerlink" title="const修饰位置不同，代表什么"></a>const修饰位置不同，代表什么</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> scottDidLoginSuccess = <span class="string">@&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure><p>咋一看，WTF，这不都张一样嘛，其实不一样，下面解释一下各代表什么</p><ol><li><code>*scottDidLoginSuccess</code>不能被修改，<code>scottDidLoginSuccess</code>能被修改</li><li><code>*scottDidLoginSuccess</code>不能被修改，<code>scottDidLoginSuccess</code>能被修改，也就是和第一种情况是一样的</li><li><code>scottDidLoginSuccess</code>不能被修改，<code>*scottDidLoginSuccess</code>能被修改。</li></ol><p><strong>结论：</strong><code>const</code>右边的总不能被修改</p><blockquote><p>所以我们一般定义一个常量又不想被修改，应该这样定义：<br>    <code>NSString *const scottDidLoginSuccess = @&quot;登陆成功&quot;;</code></p></blockquote><h2 id="两者之间的区别"><a href="#两者之间的区别" class="headerlink" title="两者之间的区别"></a>两者之间的区别</h2><ul><li><code>define</code>在预处理阶段进行替换，<code>const</code>常量在编译阶段使用；</li><li><code>define</code>不做类型检查，只进行替换，<code>const</code>常量有数据类型，会执行类型检查；</li><li><code>define</code>不能调试，<code>const</code>常量可以调试；</li><li><code>define</code>定义的常量在替换后运行过程中，会不断占用内存，而<code>const</code>定义的常量存储在数据段，只有一份拷贝，效率更高；</li><li><code>define</code>可以定义函数，<code>const</code>不可以。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在开发中，也许我们会经常使用到宏定义，或者用const修饰一些数据类型，经常有开发者不知道怎么正确使用，导致项目中乱用宏定义与const修饰符。本篇主要介绍在开发中怎么正确使用&lt;code&gt;const&lt;/code&gt;与&lt;code&gt;define(宏定义)&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="const、define" scheme="http://example.com/tags/const%E3%80%81define/"/>
    
  </entry>
  
  <entry>
    <title>利用Runtime实现简单的字典转模型</title>
    <link href="http://example.com/post/f61e800.html"/>
    <id>http://example.com/post/f61e800.html</id>
    <published>2016-06-19T03:00:15.000Z</published>
    <updated>2023-12-02T10:27:22.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，开发中会有这么一个过程，就是将服务器返回的数据转换成我们自己定义的模型对象。当然服务器返回的数据结构有<code>xml</code>类型的，也有<code>json</code>类型的。本文只讨论<code>json</code>格式的。</p><span id="more"></span><p><strong>大家在项目中一般是怎么样将服务器返回的<code>json</code>转化成自己定义的模型类呢？</strong></p><p>我在项目中一般都是使用的<a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a>。<br>本文讲解的也基本就是解读<code>MJExtension</code>中的部分源码。<br>好了，废话不多说，直接上代码，let’s go</p><h2 id="简单字典转模型"><a href="#简单字典转模型" class="headerlink" title="简单字典转模型"></a>简单字典转模型</h2><p>首先，从最简单的字典开始，例如我们需要将如下的字典转化成自定义的模型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;Scott&quot;</span>,</span><br><span class="line">                       <span class="string">@&quot;icon&quot;</span> : <span class="string">@&quot;lufy.png&quot;</span>,</span><br><span class="line">                       <span class="string">@&quot;age&quot;</span> : <span class="string">@&quot;20&quot;</span>,</span><br><span class="line">                       <span class="string">@&quot;height&quot;</span> : @<span class="number">1.75</span>,</span><br><span class="line">                       <span class="string">@&quot;money&quot;</span> : <span class="string">@&quot;100.9&quot;</span>,</span><br><span class="line">                       <span class="string">@&quot;sex&quot;</span> : @(SexMale),</span><br><span class="line">                       <span class="string">@&quot;gay&quot;</span> : <span class="string">@&quot;ture&quot;</span>,</span><br><span class="line">                       &#125;;</span><br></pre></td></tr></table></figure><p>我们定义一个<code>ScottUser</code>类，并且定义好属性名如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, Sex) &#123;</span><br><span class="line">    SexMale,    <span class="comment">// 男</span></span><br><span class="line">    SexFemale   <span class="comment">// 女</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ScottUser</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/**  姓名 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">/**  头像 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *icon;</span><br><span class="line"><span class="comment">/**  年龄 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">unsigned</span> <span class="type">int</span> age;</span><br><span class="line"><span class="comment">/**  身高 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *height;</span><br><span class="line"><span class="comment">/**  财富 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *money;</span><br><span class="line"><span class="comment">/**  性别 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Sex sex;</span><br><span class="line"><span class="comment">/**  是否同性 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isGay) <span class="type">BOOL</span> gay;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>到此为止，我们下一步的目标就是拿到字典里面的值(<code>value</code>)对<code>ScottUser</code>模型属性进行赋值，模型的属性名对应着字典里面的<code>key</code>。</p><p>最直接的方法就是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScottUser *user = [[ScottUser alloc] init];</span><br><span class="line">   user.name = dict[<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">   user.icon = dict[<span class="string">@&quot;icon&quot;</span>];</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>但是，对于每一次的数据转模型，你都要这样去写大量的重复代码，毫无意义。<br>当然我们利用<code>setValuesForKeysWithDictionary:(NSDictionary *)dict</code>进行<code>kvc</code>赋值。</p><p><strong>KVC赋值</strong></p><ul><li><strong>优点：</strong>不需要去手动一个一个属性赋值。</li><li><strong>缺点：</strong>当自定义的属性和字典中的key不一样的时候，会报错。</li><li><strong>解决办法：</strong>重写<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>方法。</li></ul><p>我们可以通过写一个框架自动帮我们实现字典转模型，大致思路就是：</p><ol><li>遍历模型中的<code>属性</code>，然后拿到<code>属性名</code>作为<code>键值</code>去字典中寻找<code>值</code>;</li><li>找到<code>值</code>后，根据模型的<code>属性类型</code>将<code>值</code>转化成正确的<code>类型</code>;</li><li>给<code>属性名</code>赋值。</li></ol><hr><h3 id="遍历模型中的属性，拿到属性名作为键值去字典中寻找值"><a href="#遍历模型中的属性，拿到属性名作为键值去字典中寻找值" class="headerlink" title="遍历模型中的属性，拿到属性名作为键值去字典中寻找值"></a>遍历模型中的<code>属性</code>，拿到<code>属性名</code>作为<code>键值</code>去字典中寻找<code>值</code></h3><p>方法伪代码：</p><pre><code>[模型类 遍历属性的方法];</code></pre><p>为了方便使用，创建一个叫<code>NSObject+ScottProperty</code>的分类，写一个获取所有属性的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">ScottProperty</span>)</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)properties;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>假设我们在看不到一个类的<code>.h</code>和<code>.m</code>文件的前提下，有什么办法可以获取它所有的实例变量呢？</p><p>答案是通过<code>Runtime</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;NSObject+ScottProperty.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">ScottProperty</span>)</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)properties &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *propertiesArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(<span class="keyword">self</span>, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        [propertiesArr addObject:propertyObj];</span><br><span class="line">        <span class="type">char</span> *name = property_getName(property);</span><br><span class="line">        <span class="type">char</span> *att = property_getAttributes(property);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;name:%s-----att:%s&quot;</span>,name,att);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> propertiesArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外部调用<code>+ (NSArray *)properties</code>方法能够打印出一个类的所有属性，如：</p><pre><code>NSArray *arr = [ScottUser properties];</code></pre><p>运行程序，能够看到控制台的输出：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension1.png" alt="图1"></p><p>从输出中可以看到通过<code>property_getName()</code>获取每一个<code>objc_property_t</code>的<code>name</code>表示成员属性的名字，通过<code>property_getAttributes()</code>获取每一个<code>objc_property_t</code>的<code>attributes</code>表示成员属性中的一些特性(如是什么类，原子性还是非原子性，是strong还是weak还是copy,生成的成员变量名等信息…)</p><p>从苹果的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">官方文档(Objective-C Runtime Programming Guide)</a>可以得知，<code>attributes</code>是一个类型编码字符串，这个字符串以<code>T</code>作为开始，接上<code>@encode</code>类型编码和一个逗号，以<code>V</code>接上实例变量名作为结尾，在他们之间是一些其他信息，以逗号分隔，具体内容可以查看官方文档中详细的表格。</p><p>在实际赋值过程中，我们并不关心该属性的内存管理、生成的成员变量名、或者其他什么信息，在<code>attributes</code>中，只需要知道它所属的<code>类</code>或者知道什么<code>基本数据类型</code>,即<code>T</code>至<code>第一个逗号之前</code>中间的内容，如果是<code>类</code>的话还需要将<code>@</code>和<code>&quot;&quot;</code>去掉。</p><p>实际上，<code>Runtime</code>已经给我们提供获取属性名和属性特性的函数了，也就是通过<code>property_getName()</code>和<code>property_getAttributes()</code>。</p><p>这时候我们就可以获取到属性名和属性对应的属性特性了。</p><h3 id="找到值后，根据属性类型将值转化成正确的类型"><a href="#找到值后，根据属性类型将值转化成正确的类型" class="headerlink" title="找到值后，根据属性类型将值转化成正确的类型"></a>找到<code>值</code>后，根据<code>属性类型</code>将<code>值</code>转化成正确的<code>类型</code></h3><p>现在已经完成了第一步，并且拿到了<code>属性名</code>,但是数据类型还需要我们进一步截取，截取方法如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">       objc_property_t property = properties[i];</span><br><span class="line">       <span class="comment">// 为了以后方便使用，将C字符串转化成OC对象</span></span><br><span class="line"><span class="comment">//    char *name = property_getName(property);</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = @(property_getName(property));</span><br><span class="line"><span class="comment">//    char *att = property_getAttributes(property);</span></span><br><span class="line">    <span class="built_in">NSString</span> *att = @(property_getAttributes(property));</span><br><span class="line">       <span class="built_in">NSUInteger</span> loc = <span class="number">1</span>;</span><br><span class="line">       <span class="built_in">NSUInteger</span> len = [att rangeOfString:<span class="string">@&quot;,&quot;</span>].location - loc;</span><br><span class="line">       <span class="built_in">NSString</span> *type = [att substringWithRange:<span class="built_in">NSMakeRange</span>(loc, len)];</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,type);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>控制台结果显示，我们能够截取到其中的类型了：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension2.png" alt="图2"></p><p>回归到我们拿到这些<code>属性类型</code>的初衷，是为了用字典中的<code>值的类型</code>与模型中<code>属性的类型</code>进行对比，想要对比，需要拿到<code>属性的类型</code>,因此需要将这些编码转换成一个<strong>表示类的类</strong>，创建一个类用来包装类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ScottPropertyType</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/**  是否为id类型 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isIdType) <span class="type">BOOL</span> idType;</span><br><span class="line"><span class="comment">/**  是否为基本数据类型(int、float等) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isNumberType) <span class="type">BOOL</span> numberType;</span><br><span class="line"><span class="comment">/**  是否为bool类型 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isBoolType) <span class="type">BOOL</span> boolType;</span><br><span class="line"><span class="comment">/**  对象类型(如果是基本数据类型，此值为nil) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class typeClass;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>OC对象可以通过<code>Class</code>来表示类型，而基本数据类型只能用布尔来标识。</p><p>把这些名字和类型遍历出来，肯定是为了以后有用，所以需要把它们存起来，由于它们是一个”整体”,所以还是设计一个类将他们包装起来比较好，创建一个包装成员属性的类–<code>ScottProperty</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">ScottPropertyType</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ScottProperty</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/**  属性名 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">/**  成员属性的类型 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) ScottPropertyType *type;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这时，代码就可以进行重构了，将属于不同类的功能封装到对应的类上，让<code>ScottProperty</code>提供一个类方法用于返回一个将<code>objc_property_t</code>进行包装的类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">       objc_property_t property = properties[i];</span><br><span class="line">       ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];</span><br><span class="line">       [propertiesArr addObject:propertyObj];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>propertyWithProperty:</code>方法实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ScottProperty</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)propertyWithProperty:(objc_property_t)property &#123;</span><br><span class="line">    <span class="keyword">return</span> [[ScottProperty alloc] initWithProperty:property];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithProperty:(objc_property_t)property &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _name = @(property_getName(property));</span><br><span class="line">        _type = [ScottPropertyType propertiesWithAttributeString:@(property_getAttributes(property))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>ScottPropertyType</code>也提供类方法用于包装类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ScottPropertyType.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ScottPropertyType</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)propertiesWithAttributeString:(<span class="built_in">NSString</span> *)att &#123;</span><br><span class="line">    <span class="keyword">return</span> [[ScottPropertyType alloc] initWithTypeString:att];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTypeString:(<span class="built_in">NSString</span> *)typeString &#123;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> loc = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> len = [typeString rangeOfString:<span class="string">@&quot;,&quot;</span>].location - loc;</span><br><span class="line">        <span class="built_in">NSString</span> *typeCode = [typeString substringWithRange:<span class="built_in">NSMakeRange</span>(loc, len)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,typeCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>重构完成之后，结构显得更加清晰，更加有利于接下来的工作，下面继续完成<code>typeCode</code>的提取。<br>运行重构之后的代码，可以看到和重构之前是一样的：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension3.png" alt="图3"></p><p>上面提到的这些类型，是类型编码，在苹果文档中告诉我们编码对应的类型：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension4.png" alt="图4"><br>根据这个对应关系的图表，我们将常用的几个编码定义成常量字符串或者宏表示它所对应的类型，利于编码和阅读：<br>在<code>ScottPropertyType</code>类定义以下属性类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  成员变量类型（属性类型）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeInt = <span class="string">@&quot;i&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeShort = <span class="string">@&quot;s&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeFloat = <span class="string">@&quot;f&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeDouble = <span class="string">@&quot;d&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeLong = <span class="string">@&quot;q&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeChar = <span class="string">@&quot;c&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeBOOL1 = <span class="string">@&quot;c&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeBOOL2 = <span class="string">@&quot;b&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypePointer = <span class="string">@&quot;*&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeIvar = <span class="string">@&quot;^&#123;objc_ivar=&#125;&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeMethod = <span class="string">@&quot;^&#123;objc_method=&#125;&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeBlock = <span class="string">@&quot;@?&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeClass = <span class="string">@&quot;#&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeSEL = <span class="string">@&quot;:&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> ScottPropertyTypeId = <span class="string">@&quot;@&quot;</span>;</span><br></pre></td></tr></table></figure><p>并写一个方法用于提取每个属性的类型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTypeString:(<span class="built_in">NSString</span> *)typeString &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> loc = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> len = [typeString rangeOfString:<span class="string">@&quot;,&quot;</span>].location - loc;</span><br><span class="line">        <span class="built_in">NSString</span> *typeCode = [typeString substringWithRange:<span class="built_in">NSMakeRange</span>(loc, len)];</span><br><span class="line">        [<span class="keyword">self</span> getTypeCode:typeCode];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)getTypeCode:(<span class="built_in">NSString</span> *)code &#123;</span><br><span class="line">    <span class="keyword">if</span> ([code isEqualToString:ScottPropertyTypeId]) &#123;</span><br><span class="line">        _idType = <span class="literal">YES</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (code.length &gt; <span class="number">3</span> &amp;&amp; [code hasPrefix:<span class="string">@&quot;@\&quot;&quot;</span>])&#123;</span><br><span class="line">        <span class="comment">// 去掉@&quot;和&quot;，截取中间的类型名称</span></span><br><span class="line">        code = [code substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, code.length - <span class="number">3</span>)];</span><br><span class="line">        _typeClass = <span class="built_in">NSClassFromString</span>(code);</span><br><span class="line">        _numberType = (_typeClass == [<span class="built_in">NSNumber</span> <span class="keyword">class</span>] || [_typeClass isSubclassOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否为数字类型</span></span><br><span class="line">    <span class="built_in">NSString</span> *lowerCode = code.lowercaseString;</span><br><span class="line">    <span class="built_in">NSArray</span> *numberTypes = @[ScottPropertyTypeInt,</span><br><span class="line">                             ScottPropertyTypeShort,</span><br><span class="line">                             ScottPropertyTypeFloat,</span><br><span class="line">                             ScottPropertyTypeDouble,</span><br><span class="line">                             ScottPropertyTypeLong,</span><br><span class="line">                             ScottPropertyTypeChar,</span><br><span class="line">                             ScottPropertyTypeBOOL1,</span><br><span class="line">                             ScottPropertyTypeBOOL2];</span><br><span class="line">    <span class="keyword">if</span> ([numberTypes containsObject:lowerCode]) &#123;</span><br><span class="line">        _numberType = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">if</span> ([lowerCode isEqualToString:ScottPropertyTypeBOOL1] || [lowerCode isEqualToString:ScottPropertyTypeBOOL2]) &#123;</span><br><span class="line">            _boolType = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们一个<code>ScottProperty</code>的骨架大致就搭好了。</p><p>在<code>NSObject+ScottProperty</code>分类中遍历属性的时候，打印属性名和属性类型看看：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];</span><br><span class="line">        [propertiesArr addObject:propertyObj];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;name:%@--type:%@&quot;</span>,propertyObj.name,propertyObj.type.typeClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension5.png" alt="图5"><br>从图中可以看出，属于基本类型的属性打印出来的类型是<code>null</code>，其他的都能正确打印出对应类型。</p><p>当我们想要使用字典转模型功能的时候，提供一个类方法方便转换，该方法放在<code>NSObject+ScottKeyValue</code>分类中，该分类负责字典转模型的方法实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)objectWithKeyValues:(<span class="type">id</span>)keyValues &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyValues) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> alloc] init] setKeyValues:keyValues];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)setKeyValues:(<span class="type">id</span>)keyValues &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *propertiesArray = [<span class="keyword">self</span>.class properties];</span><br><span class="line">    <span class="keyword">for</span> (ScottProperty *property <span class="keyword">in</span> propertiesArray) &#123;</span><br><span class="line">        ScottPropertyType *type = property.type;</span><br><span class="line">        Class typeClass = type.typeClass;</span><br><span class="line">        <span class="keyword">if</span> (type.isBoolType) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Bool&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.isIdType)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;ID&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.isNumberType)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Number&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,typeClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要字典转模型的时候，直接如下使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;Scott&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;icon&quot;</span> : <span class="string">@&quot;lufy.png&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;age&quot;</span> : <span class="string">@&quot;20&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;height&quot;</span> : @<span class="number">1.75</span>,</span><br><span class="line">                          <span class="string">@&quot;money&quot;</span> : <span class="string">@&quot;100.9&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;sex&quot;</span> : @(SexMale),</span><br><span class="line">                          <span class="string">@&quot;gay&quot;</span> : <span class="string">@&quot;ture&quot;</span>,</span><br><span class="line">                          &#125;;</span><br><span class="line">   ScottUser *userModel = [ScottUser objectWithKeyValues:dict];</span><br></pre></td></tr></table></figure><p>ok,运行程序，可以看到控制台输出<code>ScottUser</code>类中各属性对应的类型：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension6.png" alt="图6"></p><p>我们进行下一步：<strong>用该属性名作为键去字典中寻找对应的值</strong></p><p>伪代码：</p><pre><code>[字典 valueForKey:属性名];</code></pre><p>此处的属性名会有点问题，例如我们定义属性名的时候不能是关键字，而如果字典中的<code>key</code>是涉及到关键字的，那么我们需要转换，但是也并非所有的都有这种情况，因此我们可以想到使用代理。我们在<code>NSObject+ScottKeyValue</code>分类中写一个<code>ScottKeyValue</code>协议，并且让它遵守该协议:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ScottKeyValue</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)replacedKeyFromPropertyName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后我们提供一个类方法，用于处理将属性名与字典中的<code>key</code>达到一致。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)propertyKey:(<span class="built_in">NSString</span> *)propertyName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(replacedKeyFromPropertyName)]) &#123;</span><br><span class="line">        key = [<span class="keyword">self</span> replacedKeyFromPropertyName][propertyName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key ? key : propertyName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 属性名作为键去寻找对应的值</span></span><br><span class="line">   <span class="type">id</span> value = [keyValues valueForKey:[<span class="keyword">self</span>.class propertyKey:property.name]];</span><br><span class="line">   <span class="keyword">if</span> (!value) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,value);</span><br></pre></td></tr></table></figure><p>运行，我们可以看到已经能够拿到值了：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension7.png" alt="图7"></p><p>接下来，我们拿到值后将值的类型转换为属性对应的数据类型。</p><p>首先需要处理数字类型，如果模型的属性是数字类型，即<code>type.isNumberType == YES</code>,如果字典中的值是字符串类型，需要将其转成NSNumber类型，如果本来就是基本数据类型，则不用进行任何转换。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type.isNumberType == <span class="literal">YES</span>) &#123;</span><br><span class="line">      <span class="comment">// 字符串--&gt;数字</span></span><br><span class="line">      <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">          value = [[[<span class="built_in">NSNumberFormatter</span> alloc] init] numberFromString:value];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一种情况，是需要进行特殊处理的，当模型的属性是<code>char</code>类型或者<code>bool</code>类型时，获取到的编码都是<code>c</code>,并且<code>bool</code>还有可能是<code>B</code>编码，它们都对应<code>_boolType</code>，因为数字类型包含布尔类型，所以<code>bool</code>类型要在数字类型的条件下进行额外判断。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type.isNumberType == <span class="literal">YES</span>) &#123;</span><br><span class="line">       <span class="built_in">NSString</span> *oldValue = value;</span><br><span class="line">       <span class="comment">// 字符串--&gt;数字</span></span><br><span class="line">       <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">           value = [[[<span class="built_in">NSNumberFormatter</span> alloc] init] numberFromString:value];</span><br><span class="line">           <span class="keyword">if</span> (type.isBoolType) &#123;</span><br><span class="line">               <span class="built_in">NSString</span> *lower = [oldValue lowercaseString];</span><br><span class="line">               <span class="keyword">if</span> ([lower isEqualToString:<span class="string">@&quot;yes&quot;</span>] || [lower isEqualToString:<span class="string">@&quot;ture&quot;</span>]) &#123;</span><br><span class="line">                   value = @YES;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([lower isEqualToString:<span class="string">@&quot;no&quot;</span>] || [lower isEqualToString:<span class="string">@&quot;false&quot;</span>])&#123;</span><br><span class="line">                   value = @NO;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//  然后处理其他类型转化成字符串类型的情况：</span></span><br><span class="line">         <span class="keyword">if</span> (typeClass == [<span class="built_in">NSString</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">             <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (type.isNumberType)</span><br><span class="line">                     <span class="comment">// NSNumber -&gt; NSString</span></span><br><span class="line">                     value = [value description];</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">                 <span class="comment">// NSURL -&gt; NSString</span></span><br><span class="line">                 value = [value absoluteString];</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">// 最后赋值      </span></span><br><span class="line">     [<span class="keyword">self</span> setValue:value forKey:property.name];</span><br></pre></td></tr></table></figure><p>最后我们调用并打印</p><pre><code>ScottUser *userModel = [ScottUser objectWithKeyValues:dict];    NSLog(@&quot;name:%@,icon:%@,age:%d,height:%@,money:%@,sex:%ld,gay:%d&quot;,userModel.name,userModel.icon,userModel.age,userModel.height,userModel.money,(long)userModel.sex,userModel.gay);</code></pre><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension8.png" alt="图8"></p><p>到这里最简单的字典转模型大致完成了，当然还有很多的细节没有完善，后面再做处理。</p><h2 id="JSON字符串转模型"><a href="#JSON字符串转模型" class="headerlink" title="JSON字符串转模型"></a>JSON字符串转模型</h2><p>定义一个<code>json</code>字符串转成模型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - JSON字符串转模型</span></span><br><span class="line"><span class="type">void</span> keyValues2object1()&#123;</span><br><span class="line">    <span class="comment">// 1.定义一个json字符串</span></span><br><span class="line">    <span class="built_in">NSString</span> *jsonString = <span class="string">@&quot;&#123;\&quot;name\&quot;:\&quot;scott\&quot;,\&quot;icon\&quot;:\&quot;lufy.png\&quot;,\&quot;age\&quot;:20&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.将json字符串转为LZUser模型</span></span><br><span class="line">    ScottUser *user = [ScottUser objectWithKeyValues:jsonString];</span><br><span class="line">    <span class="comment">// 3.打印模型属性</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;name=%@, icon=%@, age=%d&quot;</span>,user.name,user.icon,user.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，这时程序会华丽丽的崩溃，因为程序原来只对字典类型作了处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以定位到程序崩溃在这里</span></span><br><span class="line"><span class="type">id</span> value = [keyValues valueForKey:[<span class="keyword">self</span>.class propertyKey:property.name]];</span><br></pre></td></tr></table></figure><p>所以在这之前需要将<code>JSON</code>转成<code>Foundation</code>框架中的对象，苹果提供了强大的<code>NSJSONSerialization</code>，利用它，在刚开始传入字典&#x2F;<code>JSON</code>字符串的时候将其进行转换。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)setKeyValues:(<span class="type">id</span>)keyValues &#123; </span><br><span class="line">    keyValues = [keyValues JSONObject]; </span><br><span class="line">    <span class="built_in">NSArray</span> *propertiesArray = [<span class="keyword">self</span>.class properties];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现如下，如果当前是字符串，则转换成<code>NSData</code>再进行序列化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)JSONObject &#123;</span><br><span class="line">    <span class="type">id</span> foundationObj;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = (<span class="built_in">NSString</span> *)<span class="keyword">self</span>;</span><br><span class="line">        foundationObj = [<span class="built_in">NSJSONSerialization</span>  JSONObjectWithData:[str dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>] options:kNilOptions error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]])&#123;</span><br><span class="line">        foundationObj = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:(<span class="built_in">NSData</span> *)<span class="keyword">self</span> options:kNilOptions error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果foundationObj有值，则返回foundationObj，否则返回self</span></span><br><span class="line">    <span class="keyword">return</span> foundationObj ? : <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，运行程序，OK，能够看到控制台能正确输入结果：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension9.png" alt="图9"></p><h2 id="复杂字典转模型"><a href="#复杂字典转模型" class="headerlink" title="复杂字典转模型"></a>复杂字典转模型</h2><p>定义一个模型中包含模型的复杂字典：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@&quot;text&quot;</span>:<span class="string">@&quot;是啊，今天天气确实不错！&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;user&quot;</span>:@&#123;</span><br><span class="line">                                  <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;scott&quot;</span>,</span><br><span class="line">                                  <span class="string">@&quot;icon&quot;</span>:<span class="string">@&quot;lufy.png&quot;</span></span><br><span class="line">                                  &#125;,</span><br><span class="line">                          <span class="string">@&quot;retweetedStatus&quot;</span>:@&#123;</span><br><span class="line">                                  <span class="string">@&quot;text&quot;</span>:<span class="string">@&quot;是啊，今天天气确实不错&quot;</span>,</span><br><span class="line">                                  <span class="string">@&quot;user&quot;</span>:@&#123;</span><br><span class="line">                                          <span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;scott_status&quot;</span>,</span><br><span class="line">                                          <span class="string">@&quot;icon&quot;</span>:<span class="string">@&quot;lufy_status.png&quot;</span></span><br><span class="line">                                          &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line">                          &#125;;</span><br></pre></td></tr></table></figure><p>对待这种字典的思路，应该想到递归，当碰到模型中的属性类型是一个模型类时，将字典中的<code>value</code>作为字典处理，然后再调用字典转模型的方法返回一个模型类，所以在包装类型时还要有个属性表示它是否是自定义的模型类，才能作为依据继续递归，判断的方法是看它是否来自于<code>Foundation框架</code>的类。<br>在<code>ScottPropertyType</code>中添加一个属性:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  是否来源于Foundation框架，比如NSString,NSArray等 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFromFoundation) <span class="type">BOOL</span> fromFoundation;</span><br></pre></td></tr></table></figure><p>在<code>- (void)getTypeCode:(NSString *)code</code>方法中添加这样一条:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (code.length &gt; <span class="number">3</span> &amp;&amp; [code hasPrefix:<span class="string">@&quot;@\&quot;&quot;</span>])&#123;</span><br><span class="line">       <span class="comment">// 去掉@&quot;和&quot;，截取中间的类型名称</span></span><br><span class="line">       code = [code substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, code.length - <span class="number">3</span>)];</span><br><span class="line">       _typeClass = <span class="built_in">NSClassFromString</span>(code);</span><br><span class="line">       _numberType = (_typeClass == [<span class="built_in">NSNumber</span> <span class="keyword">class</span>] || [_typeClass isSubclassOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]);</span><br><span class="line">       <span class="comment">// 判断是否来自于foundation框架</span></span><br><span class="line">       _fromFoundation = [<span class="built_in">NSObject</span> isClassFromFoundation:_typeClass];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>NSObject+ScottProperty</code>分类中添加一个类方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于判断当前类是否来自于foundation框架</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isClassFromFoundation:(Class)c;</span><br></pre></td></tr></table></figure><p>那么问题来了，如果判断是否来自于<code>Foundation框架</code>呢？ 下图展示了<code>Foundation框架(NSObject部分)</code>下的类结构:<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension10.png" alt="图10"></p><p>用一个<code>NSSet</code>(比用<code>NSArray</code>检索效率更高)，返回一些常用基本的<code>Foundation框架</code>下继承自<code>NSObject</code>的类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSSet</span> *foundationClasses_;</span><br><span class="line">+ (<span class="built_in">NSSet</span> *)foundationClass &#123;</span><br><span class="line">    <span class="keyword">if</span> (foundationClasses_ == <span class="literal">nil</span>) &#123;</span><br><span class="line">        foundationClasses_ = [<span class="built_in">NSSet</span> setWithObjects:[<span class="built_in">NSURL</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSValue</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSData</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSArray</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSString</span> <span class="keyword">class</span>],</span><br><span class="line">                              [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>], <span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foundationClasses_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以判断是否是<code>foundation框架</code>的类方法具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)isClassFromFoundation:(Class)c &#123;</span><br><span class="line">    <span class="comment">// 因为foundationClasses_里面的类都是继承NSObject，因此NSObject不能放到上面的集合，需要额外做判断</span></span><br><span class="line">    <span class="keyword">if</span> (c == [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    __block <span class="type">BOOL</span> result = <span class="literal">NO</span>;</span><br><span class="line">    [[<span class="keyword">self</span> foundationClass] enumerateObjectsUsingBlock:^(Class foundationClass, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([c isSubclassOfClass:foundationClass]) &#123;</span><br><span class="line">            result = <span class="literal">YES</span>;</span><br><span class="line">            *stop = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果后，需要在<code>NSObject+ScottKeyValue</code>分类中的<code>setKeyValues:</code>方法中添加如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不是来自foundation框架的类并且不是基本数据类型 ,则递归,如果是基本数据类型，typeClass为nil</span></span><br><span class="line"><span class="keyword">if</span> (!type.isFromFoundation &amp;&amp; typeClass) &#123;</span><br><span class="line">    value = [typeClass objectWithKeyValues:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，复杂字典转模型就算是完成了，具体调用的过程看源码<strong>文章结尾会给地址</strong>。</p><h2 id="字典数组转模型"><a href="#字典数组转模型" class="headerlink" title="字典数组转模型"></a>字典数组转模型</h2><p>稍微复杂的一种情况是一个字典里面带有数组：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</span><br><span class="line">                          <span class="string">@&quot;statuses&quot;</span> : @[</span><br><span class="line">                                  @&#123;</span><br><span class="line">                                      <span class="string">@&quot;text&quot;</span> : <span class="string">@&quot;今天天气真不错！&quot;</span>,</span><br><span class="line">                                      <span class="string">@&quot;user&quot;</span> : @&#123;</span><br><span class="line">                                              <span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;Rose&quot;</span>,</span><br><span class="line">                                              <span class="string">@&quot;icon&quot;</span> : <span class="string">@&quot;nami.png&quot;</span></span><br><span class="line">                                              &#125;</span><br><span class="line">                                      &#125;,</span><br><span class="line">                                  @&#123;</span><br><span class="line">                                      <span class="string">@&quot;text&quot;</span> : <span class="string">@&quot;明天去旅游了&quot;</span>,</span><br><span class="line">                                      <span class="string">@&quot;user&quot;</span> : @&#123;</span><br><span class="line">                                              <span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;Jack&quot;</span>,</span><br><span class="line">                                              <span class="string">@&quot;icon&quot;</span> : <span class="string">@&quot;lufy.png&quot;</span></span><br><span class="line">                                              &#125;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  ],</span><br><span class="line">                          <span class="string">@&quot;ads&quot;</span> : @[</span><br><span class="line">                                  @&#123;</span><br><span class="line">                                      <span class="string">@&quot;image&quot;</span> : <span class="string">@&quot;ad01.png&quot;</span>,</span><br><span class="line">                                      <span class="string">@&quot;url&quot;</span> : <span class="string">@&quot;http://www.baidu.com&quot;</span></span><br><span class="line">                                      &#125;,</span><br><span class="line">                                  @&#123;</span><br><span class="line">                                      <span class="string">@&quot;image&quot;</span> : <span class="string">@&quot;ad02.png&quot;</span>,</span><br><span class="line">                                      <span class="string">@&quot;url&quot;</span> : <span class="string">@&quot;http://www.sina.com&quot;</span></span><br><span class="line">                                      &#125;</span><br><span class="line">                                  ],</span><br><span class="line">                          <span class="string">@&quot;totalNumber&quot;</span> : <span class="string">@&quot;2014&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;previousCursor&quot;</span> : <span class="string">@&quot;13476589&quot;</span>,</span><br><span class="line">                          <span class="string">@&quot;nextCursor&quot;</span> : <span class="string">@&quot;13476599&quot;</span></span><br><span class="line">                          &#125;;</span><br></pre></td></tr></table></figure><p>上面定义了一个字典，创建一个<code>ScottStatusResult</code>模型，里面有两个数组，另外还有其他3个键：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ScottStatusResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 存放着某一页微博数据（里面都是Status模型） */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *statuses;</span><br><span class="line"><span class="comment">/** 存放着一堆的广告数据（里面都是Ad模型） */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *ads;</span><br><span class="line"><span class="comment">/** 总数 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *totalNumber;</span><br><span class="line"><span class="comment">/** 上一页的游标 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> <span class="type">long</span> previousCursor;</span><br><span class="line"><span class="comment">/** 下一页的游标 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> <span class="type">long</span> nextCursor;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于一个数组来说，你必须要告诉方法里面装的是什么模型，才能将字典中值为数组的成员转成模型。<br>在<code>MJExtension</code>中，提供了两种方式进行处理。</p><ul><li><p>方式一：调用<code>NSObject</code>分类中的类方法：</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ScottStatusResult setupObjectClassInArray:^<span class="built_in">NSDictionary</span> *&#123;</span><br><span class="line"> <span class="keyword">return</span> @&#123; <span class="string">@&quot;statuses&quot;</span> : <span class="string">@&quot;ScottStatus&quot;</span>,</span><br><span class="line">  <span class="comment">// 或者 @&quot;statuses&quot; : [ScottStatus class],</span></span><br><span class="line">           <span class="string">@&quot;ads&quot;</span> : <span class="string">@&quot;ScottAd&quot;</span></span><br><span class="line">  <span class="comment">// 或者 @&quot;ads&quot; : [ScottAd class]</span></span><br><span class="line">               &#125;;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></li><li><p>方式二：在模型的.m文件中实现方法供回调：</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)objectClassInArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="string">@&quot;statuses&quot;</span> : <span class="string">@&quot;ScottStatus&quot;</span>,</span><br><span class="line">              <span class="comment">// 或者 @&quot;statuses&quot; : [ScottStatus class],</span></span><br><span class="line">             <span class="string">@&quot;ads&quot;</span> : <span class="string">@&quot;ScottAd&quot;</span></span><br><span class="line">             <span class="comment">// 或者 @&quot;ads&quot; : [ScottAd class]</span></span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>原理上都差不多，都是通过代码进行回调，这个主要实现方式二。<br>在<code>NSObject+ScottKeyValue</code>分类中的<code>ScottKeyValue</code>协议中添加一个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)objectClassInArray;</span><br></pre></td></tr></table></figure><p>在<code>NSObject+ScottKeyValue</code>分类中的<code>setKeyValues:</code>方法中添加一种类型判断</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不是来自foundation框架的类并且不是基本数据类型 ,则递归,如果是基本数据类型，typeClass为nil</span></span><br><span class="line">      <span class="keyword">if</span> (!type.isFromFoundation &amp;&amp; typeClass) &#123;</span><br><span class="line">          value = [typeClass objectWithKeyValues:value];</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.class respondsToSelector:<span class="keyword">@selector</span>(objectClassInArray)])&#123; <span class="comment">// 看该类是否实现了objectClassInArray方法</span></span><br><span class="line">          <span class="type">id</span> objectClass;</span><br><span class="line">          objectClass = [<span class="keyword">self</span>.class objectClassInArray][property.name];</span><br><span class="line">         <span class="comment">// 如果是NSString类型</span></span><br><span class="line">         <span class="keyword">if</span> ([objectClass isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">             objectClass = <span class="built_in">NSClassFromString</span>(objectClass);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (objectClass) &#123;</span><br><span class="line">             <span class="comment">// 返回一个装了模型的数组</span></span><br><span class="line">             value = [objectClass objectArrayWithKeyValuesArray:value];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>返回一个装了模型的数组方法实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据字典/JSON返回模型数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param keyValuesArray 字典/JSON数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 模型数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSMutableArray</span> *)objectArrayWithKeyValuesArray:(<span class="type">id</span>)keyValuesArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isClassFromFoundation:<span class="keyword">self</span>])</span><br><span class="line">        <span class="keyword">return</span> keyValuesArray;</span><br><span class="line">    keyValuesArray = [keyValuesArray JSONObject];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *modelArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *keyValues <span class="keyword">in</span> keyValuesArray) &#123;</span><br><span class="line">        <span class="type">id</span> model;</span><br><span class="line">        model = [<span class="keyword">self</span> objectWithKeyValues:keyValues];</span><br><span class="line">        <span class="keyword">if</span> (model) &#123;</span><br><span class="line">            [modelArray addObject:model];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> modelArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，字典数组转模型就算是完成了，具体调用的过程看源码<strong>文章结尾会给地址</strong>。</p><h2 id="key的替换"><a href="#key的替换" class="headerlink" title="key的替换"></a>key的替换</h2><p>在实际开发中，服务器通常返回一个字段名<code>id</code>,或者<code>description</code>的<code>JSON</code>数据,而这两个名字在<code>OC</code>中有特殊含义,在定义属性的时候并不能使用这类名称.这时属性名与字典<code>key</code>不再是直接对应的关系,需要加入一层转换。<br>这个在前面<strong>用该属性名作为键去字典中寻找对应的值</strong>讲到过，在次就不再重复讲解。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>将5个字典转模型的例子同时运行，在<code>NSObject+ScottProperty</code>分类中的<code>+ (NSArray *)properties</code>方法中添加一句打印<code>NSLog(@&quot;%@调用了properties方法&quot;,[self class]);</code>。另外，之前的例子都是有内存泄露的，这里添加了<code>free(properties);</code>修复了这个问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)properties &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@调用了properties方法&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *propertiesArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(<span class="keyword">self</span>, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];</span><br><span class="line">        [propertiesArr addObject:propertyObj];</span><br><span class="line">    &#125;</span><br><span class="line">    free(properties);</span><br><span class="line">    <span class="keyword">return</span> propertiesArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，可以看到控制台输出：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension11.png" alt="图11"><br>可以看到,很多的类都不止一次调用了获取属性的方法,对于一个类来说,要获取它的全部属性,只要获取一次就够了.获取到后将结果缓存起来,下次就不必进行不必要的计算。<br>下面进行优化：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个全局字典用来将类的属性都缓存起来</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *cachedProperties_;</span><br><span class="line">+ (<span class="type">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    cachedProperties_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将方法改写为:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)properties &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *propertiesArr = cachedProperties_[<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="keyword">if</span> (!propertiesArr) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@调用了properties方法&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        propertiesArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        objc_property_t *properties = class_copyPropertyList(<span class="keyword">self</span>, &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];</span><br><span class="line">            [propertiesArr addObject:propertyObj];</span><br><span class="line">            <span class="comment">//        NSLog(@&quot;name:%@--type:%@&quot;,propertyObj.name,propertyObj.type.typeClass);</span></span><br><span class="line">            <span class="comment">// 为了以后方便使用，将C字符串转化成OC对象</span></span><br><span class="line">            <span class="comment">//        char *name = property_getName(property);</span></span><br><span class="line">            <span class="comment">//        NSString *name = @(property_getName(property));</span></span><br><span class="line">            <span class="comment">//        char *att = property_getAttributes(property);</span></span><br><span class="line">            <span class="comment">//        NSString *att = @(property_getAttributes(property));</span></span><br><span class="line">            <span class="comment">//        NSUInteger loc = 1;</span></span><br><span class="line">            <span class="comment">//        NSUInteger len = [att rangeOfString:@&quot;,&quot;].location - loc;</span></span><br><span class="line">            <span class="comment">//        NSString *type = [att substringWithRange:NSMakeRange(loc, len)];</span></span><br><span class="line">            <span class="comment">//        NSLog(@&quot;%@&quot;,type);</span></span><br><span class="line">        &#125;</span><br><span class="line">        free(properties);</span><br><span class="line">        cachedProperties_[<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>)] = propertiesArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> propertiesArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，控制台输出：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension12.png" alt="图12"><br>可以看出每一个类只经过一次就可以获取所有属性。</p><hr><p>除了缓存属性外，提取类型编码的过程也可以进一步缓存优化性能。<br>在下面的方法中加上一句打印：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)getTypeCode:(<span class="built_in">NSString</span> *)code &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,code);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到控制台输出：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension13.png" alt="图13"></p><p>可以看到一些常用的类型例如<code>NSString</code>多次调用了该方法。提取类型时,只要知道类名(在这里也就是<code>typeCode</code>),一个<code>ScottPropertyType</code>就已经可以确定了。</p><p>重写了<code>- initWithTypeString:</code>方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *cacheTypes_;</span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    cacheTypes_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)propertiesWithAttributeString:(<span class="built_in">NSString</span> *)att &#123;</span><br><span class="line">    <span class="keyword">return</span> [[ScottPropertyType alloc] initWithTypeString:att];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTypeString:(<span class="built_in">NSString</span> *)typeString &#123;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> loc = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> len = [typeString rangeOfString:<span class="string">@&quot;,&quot;</span>].location - loc;</span><br><span class="line">        <span class="built_in">NSString</span> *typeCode = [typeString substringWithRange:<span class="built_in">NSMakeRange</span>(loc, len)];</span><br><span class="line">        <span class="keyword">if</span> (!cacheTypes_[typeCode]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> getTypeCode:typeCode];</span><br><span class="line">            cacheTypes_[typeCode] = <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension14.png" alt="图14"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>OK,到这里，我们的解读也算是完成了，由于是下班之后写的，所以花费了4天的时间，终于把此篇文章写完了，欢迎大家点评并讨论。<br>最后代码地址：—&gt;<a href="https://github.com/LZAscott/ScottExtension">戳这里</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>参考资料：<a href="http://www.jianshu.com/p/d2ecef03f19e">跟着MJExtension实现简单的字典转模型</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，开发中会有这么一个过程，就是将服务器返回的数据转换成我们自己定义的模型对象。当然服务器返回的数据结构有&lt;code&gt;xml&lt;/code&gt;类型的，也有&lt;code&gt;json&lt;/code&gt;类型的。本文只讨论&lt;code&gt;json&lt;/code&gt;格式的。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="http://example.com/categories/technology/"/>
    
    
    <category term="Runtime" scheme="http://example.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS9新特性</title>
    <link href="http://example.com/post/387a5c0e.html"/>
    <id>http://example.com/post/387a5c0e.html</id>
    <published>2016-06-15T13:46:49.000Z</published>
    <updated>2023-12-02T10:27:22.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近这两天，微博、朋友圈里面被WWDC的内容刷屏，讲的都是关于<code>watch OS</code>、<code>tv OS</code>、<code>mac OS</code>以及<code>iOS</code>上面的一些更新，当然目前的我比较关心的是<code>iOS</code>方面的改变。也是奇怪，别人都出iOS10的系统了，我还在这写iOS9的新特性,好吧，写此篇文章是为了总结一下，以便于以后查看。</p><span id="more"></span><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul><li><p>摘要：为了增强数据访问安全，iOS9默认会把所有的<code>http</code>请求都改为<code>https</code>请求，iOS9.x-SDK编译时，默认会让所有从<code>NSURLConnection</code>、<code>CFURL</code>、<code>NSURLSession</code>发出的<code>http</code>请求统一采用<code>TLS1.2协议</code>。服务器因此需要更新，以解析相关数据。如果不更新，可以通过在info.plist中声明，倒退回不安全的网络请求。而这一做法，官方文档称为<code>ATS</code>,全称为<code>App Transport Security</code>,是iOS9的一个新特性。</p></li><li><p>一个符合<code>ATS</code>的<code>https</code>，应该符合如下条件：</p><ol><li><code>Transport Layer Security</code>协议版本要求TLS1.2以上；</li><li>服务的<code>Ciphers</code>配置要求支持<code>Forward Secrecy</code>等；</li><li>证书签名算法符合ATS要求等。</li></ol></li><li><p>如果我们服务器不更新，我们访问的还是<code>http</code>链接，我们该怎么办呢？</p><p>我们在工程的info.plist文件中添加如下图所示的代码即可：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/iOS91.png" alt="图1"></p></li></ul><h2 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h2><ul><li><p>未来,Watch应用必须包含bitcode,iOS不强制，Mac OS不支持。但是最坑的一点是：Xcode7及以上版本会默认开启bitcode。</p></li><li><p>什么是bitcode?</p><p>  官方文档的定义是这样的：</p><blockquote><p>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.</p></blockquote><p>  翻译过来就是:</p><blockquote><p>bitcode 是被编译程序的一种中间形式的代码。包含 bitcode 配置的程序将会在 App Store 上被编译和链接。 bitcode 允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到 App Store 上。</p></blockquote><p>  在Xcode简介中是这样描述的:</p><blockquote><p>Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.</p></blockquote><p>  翻译过来就是:</p><blockquote><p>当我们提交程序到 App Store上时， Xcode 会将程序编译为一个中间表现形式( bitcode )。然后 App store 会再将这个 bitcode 编译为可执行的64位或32位程序。</p></blockquote></li><li><p><strong>如果你的应用准备启用Bitcode编译机制，就需要注意以下的几点：</strong></p><ol><li>Xcode 7默认开启 Bitcode ，如果应用开启 Bitcode，那么其集成的其他第三方库也需要是 Bitcode 编译的包才能真正进行 Bitcode 编译;</li><li>开启 Bitcode 编译后，编译产生的 .app 体积会变大(中间代码，不是用户下载的包)，且 .dSYM 文件不能用来崩溃日志的符号化(用户下载的包是 Apple 服务重新编译产生的，有产生新的符号文件);</li><li>通过 Archive 方式上传 AppStore 的包，可以在Xcode的Organizer工具中下载对应安装包的新的符号文件。</li></ol></li></ul><h2 id="URL-Scheme引入白名单"><a href="#URL-Scheme引入白名单" class="headerlink" title="URL Scheme引入白名单"></a>URL Scheme引入白名单</h2><ul><li><p>iOS9中，如果使用<code>canOpenURL:</code>方法，该方法涉及到的<code>URL Scheme</code>必须在info.plist中将它们列为白名单，否则不能使用。key叫做<code>LSApplicationQueriesSchemes</code>,键值内容是:</p><pre><code>  &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;  &lt;array&gt;   &lt;string&gt;urlscheme&lt;/string&gt;   &lt;string&gt;urlscheme2&lt;/string&gt;   &lt;string&gt;urlscheme3&lt;/string&gt;   &lt;string&gt;urlscheme4&lt;/string&gt;  &lt;/array&gt; </code></pre></li><li><p>常见URL Scheme白名单。</p><pre><code>  &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;  &lt;array&gt;      &lt;!-- 微信 URL Scheme 白名单--&gt;      &lt;string&gt;wechat&lt;/string&gt;      &lt;string&gt;weixin&lt;/string&gt;        &lt;!-- 新浪微博 URL Scheme 白名单--&gt;      &lt;string&gt;sinaweibohd&lt;/string&gt;      &lt;string&gt;sinaweibo&lt;/string&gt;      &lt;string&gt;sinaweibosso&lt;/string&gt;      &lt;string&gt;weibosdk&lt;/string&gt;      &lt;string&gt;weibosdk2.5&lt;/string&gt;        &lt;!-- QQ、Qzone URL Scheme 白名单--&gt;      &lt;string&gt;mqqapi&lt;/string&gt;      &lt;string&gt;mqq&lt;/string&gt;      &lt;string&gt;mqqOpensdkSSoLogin&lt;/string&gt;      &lt;string&gt;mqqconnect&lt;/string&gt;      &lt;string&gt;mqqopensdkdataline&lt;/string&gt;      &lt;string&gt;mqqopensdkgrouptribeshare&lt;/string&gt;      &lt;string&gt;mqqopensdkfriend&lt;/string&gt;      &lt;string&gt;mqqopensdkapi&lt;/string&gt;      &lt;string&gt;mqqopensdkapiV2&lt;/string&gt;      &lt;string&gt;mqqopensdkapiV3&lt;/string&gt;      &lt;string&gt;mqzoneopensdk&lt;/string&gt;      &lt;string&gt;wtloginmqq&lt;/string&gt;      &lt;string&gt;wtloginmqq2&lt;/string&gt;      &lt;string&gt;mqqwpa&lt;/string&gt;      &lt;string&gt;mqzone&lt;/string&gt;      &lt;string&gt;mqzonev2&lt;/string&gt;      &lt;string&gt;mqzoneshare&lt;/string&gt;      &lt;string&gt;wtloginqzone&lt;/string&gt;      &lt;string&gt;mqzonewx&lt;/string&gt;      &lt;string&gt;mqzoneopensdkapiV2&lt;/string&gt;      &lt;string&gt;mqzoneopensdkapi19&lt;/string&gt;      &lt;string&gt;mqzoneopensdkapi&lt;/string&gt;      &lt;string&gt;mqzoneopensdk&lt;/string&gt;        &lt;!-- 支付宝  URL Scheme 白名单--&gt;      &lt;string&gt;alipay&lt;/string&gt;      &lt;string&gt;alipayshare&lt;/string&gt;  &lt;/array&gt;</code></pre></li><li><p><strong>注意：白名单上限是50个</strong></p></li></ul><h2 id="属性值nil"><a href="#属性值nil" class="headerlink" title="属性值nil"></a>属性值nil</h2><p>不知道大家有没有注意到，自从Xcode7开始，官方文档的类里面一些属性就多了一些类似<code>nonnull</code>、<code>nullable</code>、<code>null_resettable</code>这样的字眼。</p><ul><li><p><strong>nonnull：</strong>表示该属性的<code>setter</code>和<code>getter</code>方法都不能为<code>nil</code></p><pre><code>  @property (nonatomic, strong, nonnull) NSArray *names;  </code></pre><p>  也可以这样写:</p><pre><code>  @property (nonatomic, strong) NSArray * __nonnull names;</code></pre><p>  代表着<code>names</code>数组的<code>getter</code>方法和<code>setter</code>方法都不能为<code>nil</code>。</p></li><li><p><strong>nullable：</strong>表示该属性的<code>setter</code>和<code>getter</code>方法都能为<code>nil</code>。(<strong>注意：默认都是<code>nullable</code></strong>)</p><pre><code>  @property (nonatomic, strong, nullable) NSArray *names;</code></pre><p>  也可以这样写:</p><pre><code>  @property (nonatomic, strong) NSArray * __nullable names;  </code></pre><p>  代表着<code>names</code>数组的<code>getter</code>和<code>setter</code>方法都能为<code>nil</code>。</p></li><li><p><strong>null_resettable：</strong><code>setter</code>方法可以为<code>nil</code>,<code>getter</code>方法不能为<code>nil</code>。(**控制器的view就是使用这个修饰 **)</p><pre><code>  @property (nonatomic, strong, null_resettable) NSArray *array;  </code></pre><p>  <strong>注意：以下写法是错误的：</strong></p><blockquote><p><del>@property (nonatomic, strong) NSArray * __null_resettable array;</del></p></blockquote></li></ul><blockquote><p>总结：</p></blockquote><blockquote><ul><li>只能修饰对象类型，不能修饰基本类型;</li><li>既可以修饰属性，又可以修饰方法的参数和返回值;</li><li><code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>之间的属性都是添加了<code>nonnull</code>修饰的。</li></ul></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>举个🌰吧：我们定义一个可变数组，然后可以随便往数组里面添加<code>NSString</code>,<code>NSNumber</code>,<code>NSObject</code>对象。这样的话当我们取数组元素的时候返回的是<code>id</code>类型，这时候如果我们想要取长度的话，使用点语法是没有提示的。(<strong>因为id类型不可以使用点语法</strong>)，这个时候，我们可以使用<strong>泛型</strong>来修饰我们定义的可变数组。</p><pre><code>@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *names;</code></pre><p>这样子之后，我们只能往该数组里面添加字符串类型的元素了。此时我们获取元素的时候就能明确地知道是字符串类型的。</p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><p>我们定义字典也可以使用泛型</p><pre><code>// 代表着字典的key为NSString类型，value为NSNumber类型@property (nonatomic, strong) NSDictionary&lt;NSString *, NSNumber *&gt; *books;</code></pre><h3 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h3><p><strong>例子：</strong>定义一个<code>ScottBag</code>类，一个<code>ScottBook</code>类，如果我们给<code>ScottBag</code>类添加如下两个方法：</p><pre><code>@interface ScottBag : NSObject- (void)add:(id)param;- (id)get:(NSInteger *)index;</code></pre><p>那么我们可以用<code>ScottBag</code>类生成的对象去<code>add</code>任意对象。</p><hr><p>如果我们给<code>ScottBag</code>类添加自定义泛型:</p><pre><code>@interface ScottBag&lt;ObjectType&gt; : NSObject- (void)add:(ObjectType)param;- (ObjectType)get:(NSInteger *)index;</code></pre><p>那么我们可以用以下方式只能向<code>ScottBag</code>类生成的对象中添加规定的类型对象，如下，我们就规定<code>ScottBag</code>类生成的对象只能添加<code>ScottBook</code>类型的对象：</p><pre><code>ScottBag&lt;ScottBook *&gt; *bag = [[ScottBag alloc] init];// &lt;#(ScottBook *)#&gt;表示ScottBook类型的对象[bag add:&lt;#(ScottBook *)#&gt;];</code></pre><h2 id="StoryBoard-Refrence"><a href="#StoryBoard-Refrence" class="headerlink" title="StoryBoard Refrence"></a>StoryBoard Refrence</h2><p>我们都知道以前如果我们要使用StoryBoard来做项目的话，要么就是所有的控制器都放在一个StoryBoard中，通过连线的方式进行通信，要么就是通过代码来读取不同StoryBoard种的控制器来通信。</p><p>为了解决这一问题，在iOS9中引入了<code>StoryBoard Refrence</code>这个概念，<code>Storyboard Reference</code>允许你从<code>segue</code>中引用其他<code>storyboard</code>中的<code>viewController</code>。这意味中你可以保持不同功能模块化，同时<code>Storyboard</code>的体积变小并易与管理。不仅容易理解了，和团队一起工作时，合并（工作成果）也变的简单了。</p><h2 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h2><p>这个在实际开发中并没有使用到，不过大家可以自己学习。—&gt;<a href="http://www.cocoachina.com/ios/20150819/13116.html">传送门</a></p><h2 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h2><p>这个在开发中暂时没有用到，在这里记录一下学习的资料。—&gt;<a href="http://www.cocoachina.com/ios/20150623/12233.html">传送门</a></p><h2 id="3D-touch"><a href="#3D-touch" class="headerlink" title="3D touch"></a>3D touch</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在iPhone6s问世之后，很多果粉都争先要体验3D Touch给用户带来的额外维度上的交互，这个设计之所以叫做3D Touch，其原理上是增加了一个压力的感触，通过区分轻按和重按来进行不同的用户交互。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>3D Touch是一个很新颖的设计，可是苹果文档也给我们说了</p><blockquote><p>With Xcode 7.0 you must develop on a device that supports 3D Touch. Simulator in Xcode 7.0 does not support 3D Touch.</p></blockquote><p>WTF,是不是看到这里心都凉了一半，是的，Xcode7是支持3D Touch开发的，可是模拟器并不支持这个手势。由于我没有6s测试机，因此就不做深入了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近这两天，微博、朋友圈里面被WWDC的内容刷屏，讲的都是关于&lt;code&gt;watch OS&lt;/code&gt;、&lt;code&gt;tv OS&lt;/code&gt;、&lt;code&gt;mac OS&lt;/code&gt;以及&lt;code&gt;iOS&lt;/code&gt;上面的一些更新，当然目前的我比较关心的是&lt;code&gt;iOS&lt;/code&gt;方面的改变。也是奇怪，别人都出iOS10的系统了，我还在这写iOS9的新特性,好吧，写此篇文章是为了总结一下，以便于以后查看。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初识Runtime</title>
    <link href="http://example.com/post/c581c9e9.html"/>
    <id>http://example.com/post/c581c9e9.html</id>
    <published>2016-06-14T14:26:43.000Z</published>
    <updated>2023-12-02T11:32:07.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>之前在看一些第三方源码的时候，时不时的能碰到一些关于运行时相关的代码。于是乎，就阅读了一些关于运行时的文章，感觉写的都不错，写此篇文章为了记录一下，同时也重新学习一遍。</p><h2 id="二、Runtime简介"><a href="#二、Runtime简介" class="headerlink" title="二、Runtime简介"></a>二、Runtime简介</h2><ul><li>Runtime简称运行时，OC就是运行时机制。</li><li>C语言中函数的调用在编译的时候就会决定调用哪个函数。</li><li>对于OC来说，属于动态调用过程，在编译的时候并不能决定调用哪个函数，只有真正运行的时候才会根据函数的名称找到对应的函数来调用。</li><li>事实证明：<ol><li>在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明就不会报错。</li><li>在编译阶段，C语言调用未实现的函数就会报错。</li></ol></li></ul><span id="more"></span><h2 id="三、Runtime的作用"><a href="#三、Runtime的作用" class="headerlink" title="三、Runtime的作用"></a>三、Runtime的作用</h2><h3 id="3-1-发送消息"><a href="#3-1-发送消息" class="headerlink" title="3.1 发送消息"></a>3.1 发送消息</h3><ul><li><p>方法调用的本质就是向对象发送消息。</p></li><li><p><code>objc_msgSend</code>,只有对象才能发送消息，因此以<code>objc</code>开头。<strong>注意：在oc中，不论是实例对象还是Class，都是id类型的对象</strong></p></li><li><p>让我们来看看方法调用转化成运行时的代码，看看调用方法的真面目吧。</p><ol><li><p>新建一个命令行工程</p></li><li><p>然后在main方法里面写上</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">   <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用终端跳转到工程所在的根目录，然后命令行运行<code>clang -rewrite-objc main.m</code></p></li><li><p>然后ls查看一下当前目录可以看到有一个<code>main.cpp</code>文件，我们用<code>open main.cpp</code>打开该文件，可以看到一大串代码，我们可以直接翻到底部，可以看到这样的代码：</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="built_in">NSObject</span> *obj = ((<span class="built_in">NSObject</span> *(*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)((<span class="built_in">NSObject</span> *(*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)objc_getClass(<span class="string">&quot;NSObject&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除掉一些强制转换，将上面的代码简化后：</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="built_in">NSObject</span> *obj = objc_msgSend(objc_getClass(<span class="string">&quot;NSObject&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><blockquote><p>总结：到这里，我们可以看到调用方法的本质就是发送消息了，并且可以看到我们写的<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><br>上面这条语句发送了两次消息，第一次发送了<code>alloc</code>消息，第二次发送了<code>init</code>消息。</p></blockquote><h3 id="3-2-给分类添加属性"><a href="#3-2-给分类添加属性" class="headerlink" title="3.2 给分类添加属性"></a>3.2 给分类添加属性</h3><p>相信大家都知道分类是不可以添加属性的，不过我们可以通过运行时，给分类动态的添加属性。</p><p><strong>原理：</strong>给一个分类声明属性，其本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</p><h4 id="3-2-1-实践"><a href="#3-2-1-实践" class="headerlink" title="3.2.1 实践"></a>3.2.1 实践</h4><ul><li><p>我们给<code>NSObject</code>添加一个分类，然后声明一个<code>name</code>属性。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>我们创建一个<code>NSObject</code>对象，然后给<code>name</code>属性赋值，并且打印<code>name</code>的值。<br> 我们可以看到编译成功，但是运行的时候就会华丽丽的崩溃，这就是所谓的不能给分类添加属性的原因了。不过我们可以通过运行时实现。</p></li><li><p>接下来我们在.m文件重写<code>name</code>属性的<code>setter</code>以及<code>getter</code>方法。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;NSObject+Extension.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> *key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line">-(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 根据关联的key，获取关联的值</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></span><br><span class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></span><br><span class="line">    <span class="comment">// 第三个参数：关联的value</span></span><br><span class="line">    <span class="comment">// 第四个参数:关联的策略</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>运行程序，编译成功，运行也成功。</p></li></ul><h3 id="3-3-动态添加方法"><a href="#3-3-动态添加方法" class="headerlink" title="3.3 动态添加方法"></a>3.3 动态添加方法</h3><ul><li><strong>开发使用场景:</strong> 如果一个类方法非常多，加载该类到内存的时候比较耗费资源，需要给每个方法生成映射表，可以使用运行时给该类动态添加方法来解决。(<strong>ps:我感觉这个在开发中不常用</strong>)</li></ul><h4 id="3-3-1-实践"><a href="#3-3-1-实践" class="headerlink" title="3.3.1 实践"></a>3.3.1 实践</h4><ul><li><p>创建一个继承<code>NSObject</code>的<code>Student</code>类，声明一个<code>study</code>方法。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="type">void</span>)study;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个<code>Student</code>对象，调用<code>study</code>方法。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student *s = [[Student alloc] init];</span><br><span class="line">  [s performSelector:<span class="keyword">@selector</span>(study)];</span><br></pre></td></tr></table></figure><p>  此时会出现一个经典的报错：</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[Student study]: unrecognized selector sent to instance <span class="number">0x7fd719cbb2f0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>错误原因:调用一个未实现的实例方法</strong></p></blockquote></li><li><p>我们在<code>Student</code>类.m文件动态添加study方法的实现。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="comment">// void(*)()</span></span><br><span class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></span><br><span class="line"><span class="type">void</span> studyStudent(<span class="type">id</span> <span class="keyword">self</span>, SEL sel)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@--%@&quot;</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用该方法处理，并且会把对应的方法列表传进来，我们可以在这个方法里判断，未实现的方法是不是我们想要动态添加的方法。</span></span><br><span class="line">+(<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;    </span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(study)) &#123;</span><br><span class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></span><br><span class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></span><br><span class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(study), studyStudent, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意：此处需要马上结束此方法(否则，如果存在继承关系的话，会调用到父类去)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-交换方法实现"><a href="#3-4-交换方法实现" class="headerlink" title="3.4 交换方法实现"></a>3.4 交换方法实现</h3><ul><li>交换方法实现，也就是所谓的<code>Method Swizzling</code>。</li><li><strong>场景一：</strong>如果你整个项目都做完了，然后产品经理告诉你想统计每一个页面停留的时长。</li><li><strong>场景二：</strong>系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有功能。</li></ul><h4 id="3-4-1-实践"><a href="#3-4-1-实践" class="headerlink" title="3.4.1 实践"></a>3.4.1 实践</h4><p><strong>场景一：</strong>统计整个项目每一个页面停留时长。(<strong>解决方法也不是唯一的</strong>)</p><ul><li><p>方式一：找到所有的控制器，然后写上：</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">   [<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">   [MobClick beginLogPageView:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">   [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">   [MobClick endLogPageView:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后我们一个项目可能有几十个甚至上百个页面需要统计，我们总不可能每个页面都这样写吧。于是乎，就有了<strong>方式二</strong>。</p></li><li><p>方式二：所有的界面都继承于一个基类，然后在基类中写上</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">   [<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">   [MobClick beginLogPageView:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">   [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">   [MobClick endLogPageView:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可是一开始写项目的时候，并没有使用到继承，所以又papapa地就整个项目的控制器都继承于一个基类，重复地将每一个控制器的继承都该成了我们创建的基类。但是，这样解决真的好么，有可能我们有些界面是继承自<code>UITableViewController</code>的，<code>UICollectionViewController</code>，等等。那么你就可能会对这些控制器再单独的写上面的代码了。</p><p>  好不容易将整个项目改过来了，然后某天，公司来了一位新人，你告诉他所有的类都要继承自你写的那个基类，新手总是会不经意地犯错误(<strong>也有可能是人家还没有习惯</strong>)，有些类忘记继承了，后期排查起来费力费时。那么有没有更好地解决方式呢？<strong>方式三</strong>就可以处理这种问题。</p></li><li><p>方式三：使用<code>Method Swizzling</code>实现，给<code>UIViewController</code>写一个分类。</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;UIViewController+Help.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Help</span>)</span></span><br><span class="line">+(<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        methodSwizzling(<span class="keyword">class</span>, <span class="keyword">@selector</span>(viewWillAppear:), <span class="keyword">@selector</span>(scott_viewWillAppear:));</span><br><span class="line">        methodSwizzling(<span class="keyword">class</span>, <span class="keyword">@selector</span>(viewWillDisappear:), <span class="keyword">@selector</span>(scott_viewWillDisappear:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> methodSwizzling(Class <span class="keyword">class</span>, SEL originSelector, SEL swizzSelector)&#123;</span><br><span class="line">    Method originMethod = class_getInstanceMethod(<span class="keyword">class</span>, originSelector);</span><br><span class="line">    Method swizzMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzSelector);</span><br><span class="line">    <span class="type">BOOL</span> isAddMethod = class_addMethod(<span class="keyword">class</span>, originSelector, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));</span><br><span class="line">    <span class="keyword">if</span> (isAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>, swizzSelector, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        method_exchangeImplementations(originMethod, swizzMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)scott_viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> scott_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用自定义viewWillAppear&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)scott_viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> scott_viewWillDisappear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用自定义viewWillDissappear&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-字典转模型"><a href="#3-5-字典转模型" class="headerlink" title="3.5 字典转模型"></a>3.5 字典转模型</h3><p>这个单独开一篇给大家讲讲吧。</p><h2 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h2><p>希望通过本文能让大家学习到一些关于Runtime的知识，如果有什么疑问，欢迎大家一起讨论。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;之前在看一些第三方源码的时候，时不时的能碰到一些关于运行时相关的代码。于是乎，就阅读了一些关于运行时的文章，感觉写的都不错，写此篇文章为了记录一下，同时也重新学习一遍。&lt;/p&gt;
&lt;h2 id=&quot;二、Runtime简介&quot;&gt;&lt;a href=&quot;#二、Runtime简介&quot; class=&quot;headerlink&quot; title=&quot;二、Runtime简介&quot;&gt;&lt;/a&gt;二、Runtime简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Runtime简称运行时，OC就是运行时机制。&lt;/li&gt;
&lt;li&gt;C语言中函数的调用在编译的时候就会决定调用哪个函数。&lt;/li&gt;
&lt;li&gt;对于OC来说，属于动态调用过程，在编译的时候并不能决定调用哪个函数，只有真正运行的时候才会根据函数的名称找到对应的函数来调用。&lt;/li&gt;
&lt;li&gt;事实证明：&lt;ol&gt;
&lt;li&gt;在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明就不会报错。&lt;/li&gt;
&lt;li&gt;在编译阶段，C语言调用未实现的函数就会报错。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
    <category term="Runtime" scheme="http://example.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>自定义转场详解(一)</title>
    <link href="http://example.com/post/a0e5cd1a.html"/>
    <id>http://example.com/post/a0e5cd1a.html</id>
    <published>2016-06-11T12:08:15.000Z</published>
    <updated>2023-12-02T10:27:22.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文是我学习了onevcat的<a href="https://onevcat.com/2013/10/vc-transition-in-ios7/">这篇</a>转场入门做的一点笔记。</p></blockquote><span id="more"></span><p>今天我们来实现一个简单的自定义转场，我们先来看看这篇文章将要实现的一个效果图吧：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA011.gif" alt="图1"></p><h2 id="过程详解"><a href="#过程详解" class="headerlink" title="过程详解"></a>过程详解</h2><h4 id="热身准备"><a href="#热身准备" class="headerlink" title="热身准备"></a>热身准备</h4><p>我们先创建一个工程，首先用storyboard快速的创建两个控制器，一个作为主控制器，叫<code>ViewController</code>，另外一个作为present出来的控制器，叫<code>PresentViewController</code>，并且用autoLayout快速搭建好界面。就像这样：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA012.png" alt="图2"></p><p>我们先做好点击<code>ViewController</code>上面的按钮，present出<code>PresentViewController</code>，点击<code>PresentViewController</code>上面的按钮，dismiss掉<code>PresentViewController</code>的逻辑。这里有两个注意点：</p><ol><li><p>因为此处我使用了<code>segue</code>，所以在<code>ViewController</code>按钮点击的时候，我们只需要这样调用就行。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 点我弹出</span></span><br><span class="line">-(<span class="keyword">IBAction</span>)presentBtnClick:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@&quot;PresentSegue&quot;</span> sender:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们平时写dismiss的时候，一般都会是在第二个控制器中直接给self发送<code>dismissViewController</code>的相关方法。在现在的SDK中，如果当前的VC是被显示的话，这个消息会被直接转发到显示它的VC去。但是这并不是一个好的实现，违反了程序设计的哲学，也很容易掉到坑里。所以我们用标准的<code>delegate</code> 方式实现 <code>dismiss</code> 。</p></li></ol><p>首先我们在<code>PresentViewController</code>控制器中申明一个代理方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">PresentViewController</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PresentViewControllerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)dismissViewController:(PresentViewController *)viewController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PresentViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;PresentViewControllerDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在button的点击事件中，让代理去完成关闭当前控制器的工作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 点击关闭</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)closeBtnClick:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(dismissViewController:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.delegate dismissViewController:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此同时，在<code>ViewController</code>中需要设置<code>PresentViewController</code>的代理,并且实现代理方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> ([segue.identifier isEqualToString:<span class="string">@&quot;PresentSegue&quot;</span>]) &#123;</span><br><span class="line">        PresentViewController *presetVC = segue.destinationViewController;</span><br><span class="line">        presetVC.delegate = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - PresentViewControllerDelegate</span></span><br><span class="line">- (<span class="type">void</span>)dismissViewController:(PresentViewController *)viewController &#123;</span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，到这里，我们一个基本的转场就完成了(这也是系统自带的一个效果)。like this:<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA013.gif" alt="图3"></p><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><p>接下来，要接触我们今天要讲的主要内容了，我们用iOS7中一个新的类<code>UIViewControllerTransitioning</code>来实现自定义转场。</p><hr><h6 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a>UIViewControllerAnimatedTransitioning</h6><p>首先我们需要一个实现了协议名为<code>UIViewControllerAnimatedTransitioning</code>的对象。创建一个类叫做<code>PresentAnimation</code>继承于<code>NSObject</code>并且实现了<code>UIViewControllerAnimatedTransitioning</code>协议。(<strong>注意：需要导入UIKit框架</strong>)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PresentAnimation</span> : <span class="title">NSObject</span>&lt;<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个协议负责转场的具体内容。开发者在做自定义切换效果时大部门代码会是用来实现这个协议的，这个协议只有两个方法必须要实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回动画的时间</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</span><br><span class="line"><span class="comment">// 在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。</span></span><br><span class="line">- (<span class="type">void</span>)animateTransition:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</span><br></pre></td></tr></table></figure><p>实现这两个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.8</span>f;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)animateTransition:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="comment">// 1.我们需要得到参与切换的两个ViewController的信息，使用context的方法拿到它们的参照；</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];   </span><br><span class="line">    <span class="comment">// 2.对于要呈现的VC，我们希望它从屏幕下方出现，因此将初始位置设置到屏幕下边缘；</span></span><br><span class="line">    <span class="built_in">CGRect</span> finaRect = [transitionContext finalFrameForViewController:toVC];</span><br><span class="line">    toVC.view.frame = <span class="built_in">CGRectOffset</span>(finaRect, <span class="number">0</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height);</span><br><span class="line">    <span class="comment">// 3.将view添加到containerView中；</span></span><br><span class="line">    [[transitionContext containerView] addSubview:toVC.view];</span><br><span class="line">    <span class="comment">// 4.开始动画。这里的动画时间长度和切换时间长度一致。usingSpringWithDamping的UIView动画API是iOS7新加入的，描述了一个模拟弹簧动作的动画曲线；</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] delay:<span class="number">0.0</span> usingSpringWithDamping:<span class="number">0.6</span> initialSpringVelocity:<span class="number">0.0</span> options:<span class="built_in">UIViewAnimationOptionCurveLinear</span> animations:^&#123;</span><br><span class="line">        toVC.view.frame = finaRect;</span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="comment">// 5.在动画结束后我们必须向context报告VC切换完成，是否成功。系统在接收到这个消息后，将对VC状态进行维护。</span></span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点</strong></p><blockquote><p><code>UITransitionContextToViewControllerKey</code>与<code>UITransitionContextFromViewControllerKey</code><br>比如从A present 出B，此时A是<code>FromViewController</code>,B是<code>ToViewController</code><br>如果从B dismiss 到A，此时A是<code>ToViewController</code>,B是<code>FromViewController</code></p></blockquote><h6 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h6><p>这个接口的作用比较单一，在需要VC切换的时候系统会向实现了这个接口的对象询问是否需要使用自定义转场效果。<br>所以，一个比较好的地方是直接在主控制器<code>ViewController</code>中实现这个协议。</p><p>在<code>ViewController</code>中完成如下代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">PresentViewControllerDelegate</span>,<span class="title">UIViewControllerTransitioningDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PresentAnimation *presentAnimation;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 懒加载</span></span><br><span class="line">- (PresentAnimation *)presentAnimation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_presentAnimation) &#123;</span><br><span class="line">        _presentAnimation = [[PresentAnimation alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _presentAnimation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - UIViewControllerTransitioningDelegate</span></span><br><span class="line">- (<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.presentAnimation;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> ([segue.identifier isEqualToString:<span class="string">@&quot;PresentSegue&quot;</span>]) &#123;</span><br><span class="line">        PresentViewController *presetVC = segue.destinationViewController;</span><br><span class="line">        presetVC.delegate = <span class="keyword">self</span>;</span><br><span class="line">        presetVC.transitioningDelegate = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在看下我们的效果：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA014.gif" alt="图4"><br>相对于上面系统自带的效果来说，我们在present出第二个控制器的时候，带有弹簧效果。</p><h4 id="手势驱动百分比切换"><a href="#手势驱动百分比切换" class="headerlink" title="手势驱动百分比切换"></a>手势驱动百分比切换</h4><p>现在我们增加一个功能，就是用手势滑动来dismiss，通俗的说，就是让present出来的那个控制器使用手势dismiss。</p><ol><li><p>创建一个类，继承自<code>UIPercentDrivenInteractiveTransition</code></p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PanInteractiveTransition</span> : <span class="title">UIPercentDrivenInteractiveTransition</span></span></span><br><span class="line">-(<span class="type">void</span>)panToDismiss:(<span class="built_in">UIViewController</span> *)viewController;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>我们写一个方法提供给外部类调用。让外部类可以看到传入手势dismiss的VC的入口。</li></ul></li><li><p>既然传入了这个需要手势dismiss的VC,我们就需要保存一下，方便当前类在其他地方使用，所以我们新建一个属性来保存这个传入的VC。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;PanInteractiveTransition.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PanInteractiveTransition</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIViewController</span> *presentVC;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PanInteractiveTransition</span></span></span><br><span class="line">-(<span class="type">void</span>)panToDismiss:(<span class="built_in">UIViewController</span> *)viewController &#123;</span><br><span class="line">    <span class="keyword">self</span>.presentVC = viewController;</span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *panGestR = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(panGestureAction:)];</span><br><span class="line">    [<span class="keyword">self</span>.presentVC.view addGestureRecognizer:panGestR];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - panGestureAction</span></span><br><span class="line">-(<span class="type">void</span>)panGestureAction:(<span class="built_in">UIPanGestureRecognizer</span> *)pan &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> transition = [pan translationInView:<span class="keyword">self</span>.presentVC.view];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%.2f&quot;</span>,transition.y);</span><br><span class="line">    <span class="keyword">switch</span> (pan.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:&#123;</span><br><span class="line">           [<span class="keyword">self</span>.presentVC dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">       &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:&#123;  <span class="comment">//</span></span><br><span class="line">            <span class="built_in">CGFloat</span> percent = MIN(<span class="number">1.0</span>, transition.y/<span class="number">300</span>);</span><br><span class="line">            [<span class="keyword">self</span> updateInteractiveTransition:percent];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:&#123;</span><br><span class="line">            <span class="keyword">if</span> (pan.state == <span class="built_in">UIGestureRecognizerStateCancelled</span>) &#123;   <span class="comment">// 手势取消</span></span><br><span class="line">                [<span class="keyword">self</span> cancelInteractiveTransition];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                [<span class="keyword">self</span> finishInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和创建<code>PresentAnimation</code>一样，我们创建一个一个<code>DismissAnimation</code>类</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DismissAnimation</span> : <span class="title">NSObject</span>&lt;<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DismissAnimation</span></span></span><br><span class="line">-(<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.4</span>f;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)animateTransition:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">CGRect</span> initRect = [transitionContext initialFrameForViewController:fromVC];</span><br><span class="line">    <span class="built_in">CGRect</span> finalRect = <span class="built_in">CGRectOffset</span>(initRect, <span class="number">0</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height);</span><br><span class="line">    <span class="built_in">UIView</span> *contrainerView = [transitionContext containerView];</span><br><span class="line">    [contrainerView addSubview:toVC.view];</span><br><span class="line">    [contrainerView sendSubviewToBack:toVC.view];</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">        fromVC.view.frame = finalRect;</span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>最后，我们在主控制器中添加一个手势驱动的对象，一个dismiss转场的对象，然后懒加载。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(PanInteractiveTransition *)paninterTransition &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_paninterTransition) &#123;</span><br><span class="line">        _paninterTransition = [[PanInteractiveTransition alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _paninterTransition;</span><br><span class="line">&#125;</span><br><span class="line">-(DismissAnimation *)dismissAnimation &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_dismissAnimation) &#123;</span><br><span class="line">        _dismissAnimation = [[DismissAnimation alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dismissAnimation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - UIViewControllerTransitioningDelegate</span></span><br><span class="line">-(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.dismissAnimation;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.paninterTransition;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="type">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span> ([segue.identifier isEqualToString:<span class="string">@&quot;PresentSegue&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        [<span class="keyword">self</span>.paninterTransition panToDismiss:presetVC];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h4><p>此时，我们运行程序，会发现以上代码尽管可以手势驱动了，但是点击按钮dismiss的功能无法使用了。这是因为<strong>如果只是返回self.paninterTransition，那么点击按钮dismiss的动画就会失效；如果只是返回nil,那么手势滑动的效果将会失效</strong>。综上所述，我们就得分情况考虑。<br>接下来我们就来完善一下。</p><ol><li><p>给<code>PanInteractiveTransition</code>添加一个属性，表示是否处于切换过程中(用于判断使用的是点击按钮dismiss还是手势驱动来dismiss的)</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否处于切换过程中</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isInteracting) <span class="type">BOOL</span> interacting;</span><br></pre></td></tr></table></figure></li><li><p>给<code>PanInteractiveTransition</code>添加一个属性，表示是否需要dismiss(用于当手势滑动到超过指定高度之后，就会dismiss，如果没有超过，就会还原)</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isShouldComplete) <span class="type">BOOL</span> shouldComplete;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>PanInteractiveTransition</code>中的<code>panGestureAction:</code>方法：</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)panGestureAction:(<span class="built_in">UIPanGestureRecognizer</span> *)pan &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> transition = [pan translationInView:pan.view];</span><br><span class="line">    <span class="keyword">switch</span> (pan.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:&#123;</span><br><span class="line">            <span class="keyword">self</span>.interacting = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span>.presentVC dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:&#123;  <span class="comment">//</span></span><br><span class="line">            <span class="built_in">CGFloat</span> percent = fmin(fmax(transition.y/<span class="number">300.0</span>, <span class="number">0.0</span>), <span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">self</span>.shouldComplete = (percent &gt; <span class="number">0.5</span>);</span><br><span class="line">            [<span class="keyword">self</span> updateInteractiveTransition:percent];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:&#123;</span><br><span class="line">            <span class="keyword">self</span>.interacting = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">// 如果下移的距离小于300或者取消都当做取消</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">self</span>.isShouldComplete || pan.state == <span class="built_in">UIGestureRecognizerStateCancelled</span>) &#123;   <span class="comment">// 手势取消</span></span><br><span class="line">                [<span class="keyword">self</span> cancelInteractiveTransition];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                [<span class="keyword">self</span> finishInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另外还有一点，就是需要修改<code>DismissAnimation</code>中的一处代码:</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)animateTransition:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];  </span><br><span class="line">    <span class="built_in">CGRect</span> initRect = [transitionContext initialFrameForViewController:fromVC];</span><br><span class="line">    <span class="built_in">CGRect</span> finalRect = <span class="built_in">CGRectOffset</span>(initRect, <span class="number">0</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height);</span><br><span class="line">    <span class="built_in">UIView</span> *contrainerView = [transitionContext containerView];</span><br><span class="line">    [contrainerView addSubview:toVC.view];</span><br><span class="line">    [contrainerView sendSubviewToBack:toVC.view];</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">        fromVC.view.frame = finalRect;</span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">    <span class="comment">// 此处做了修改，由之前的[transitionContext completeTransition:YES];</span></span><br><span class="line">      [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>ok,到此为止，我们的一个自定义转场动画就算了完成了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文是我学习了onevcat的&lt;a href=&quot;https://onevcat.com/2013/10/vc-transition-in-ios7/&quot;&gt;这篇&lt;/a&gt;转场入门做的一点笔记。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="转场动画" scheme="http://example.com/tags/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Xcode常用快捷键</title>
    <link href="http://example.com/post/5a50c6f9.html"/>
    <id>http://example.com/post/5a50c6f9.html</id>
    <published>2016-06-08T13:02:31.000Z</published>
    <updated>2023-12-02T10:27:22.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>“工欲善其事，必先利其器”,掌握了Xcode的快捷键操作，能够大大的提升自己开发的速度，因此在这里做一下整理。可能也有些快捷键是没有写到的。</p><span id="more"></span><h2 id="二、视图导航"><a href="#二、视图导航" class="headerlink" title="二、视图导航"></a>二、视图导航</h2><ul><li>Command + 0 显示&#x2F;隐藏xcode左边导航</li><li>Command + Option + 0 显示&#x2F;隐藏xcode右边导航</li><li>Command + Shift + 0 打开官方文档</li><li>Command + 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6&#x2F;7&#x2F;8 跳转到左栏不同的栏目</li><li>Command + Shift + y 显示&#x2F;隐藏控制台</li><li>Command + Option + enter 将代码区分成2份</li><li>Command + enter 将代码区合并成1份</li></ul><h2 id="三、文本编辑"><a href="#三、文本编辑" class="headerlink" title="三、文本编辑"></a>三、文本编辑</h2><ul><li>Command + Shift + N 新建一个项目</li><li>Command + N 新建一个类</li><li>Command + &#x2F; 注释选中的代码</li><li>Ctrl + i 将代码格式化</li><li>Command + [ 和 Command + ] 左右缩进</li><li>Command + Option + [ 和 Command + Option + ] 当前行上下移动</li><li>Command + Option + Left&#x2F;Right 折叠、展开当前代码段</li><li>Command + Option + Shift + Left&#x2F;Right 折叠&#x2F;展开该文件内所有代码块</li><li>Command + z 后退代码</li><li>Command + Shift + z 前进代码</li></ul><h2 id="四、文件跳转"><a href="#四、文件跳转" class="headerlink" title="四、文件跳转"></a>四、文件跳转</h2><ul><li>Command + Control + Up&#x2F;Down .h和.m切换</li><li>Command + Control + Left&#x2F;Right 浏览历史记录切换</li><li>Command + Control + j 跳转到定义处</li><li>Command + Shift + O 文件搜索</li><li>Command + Shift + j 定位到当前类所在的位置</li></ul><h2 id="五、搜索"><a href="#五、搜索" class="headerlink" title="五、搜索"></a>五、搜索</h2><ul><li>Command + Shift + f 全局搜索</li><li>Command + e 搜索当前选中的单词</li><li>Command + f 当前文件内搜索</li><li>Command + Option + f 当前文件内替换</li><li>Command + g 搜索下一个</li></ul><h2 id="六、tab"><a href="#六、tab" class="headerlink" title="六、tab"></a>六、tab</h2><ul><li>Command + t 新建一个tab</li><li>Command + w 关闭当前tab</li><li>Command + Shift + [ 和 Command + Shift + ] 左右切换tab</li></ul><h2 id="七、Scheme"><a href="#七、Scheme" class="headerlink" title="七、Scheme"></a>七、Scheme</h2><ul><li>Command + Shift + , 编辑scheme,选择debug或release</li></ul><h2 id="八、调试"><a href="#八、调试" class="headerlink" title="八、调试"></a>八、调试</h2><ul><li>fn + F6 跳到下一条指令</li><li>fn + F7 跳进下一条指令(跳进内部函数)</li><li>Command + Control + y 继续运行</li><li>Command + | 打开&#x2F;关闭断点</li><li>Command + y 全局激活或者禁用所有的断点</li></ul><h2 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h2><ul><li>Command + B 编译项目</li><li>Command + R 运行项目</li><li>Command + . 终止运行项目</li><li>Command + k 清空xcode控制台中的内容</li><li>Command + Shift + k 清理项目(针对Xcode)</li><li>Command + Shift + k 隐藏&#x2F;显示键盘(针对模拟器)</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;“工欲善其事，必先利其器”,掌握了Xcode的快捷键操作，能够大大的提升自己开发的速度，因此在这里做一下整理。可能也有些快捷键是没有写到的。&lt;/p&gt;</summary>
    
    
    
    <category term="Xcode" scheme="http://example.com/categories/Xcode/"/>
    
    
    <category term="Xcode" scheme="http://example.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa(二)</title>
    <link href="http://example.com/post/8615c104.html"/>
    <id>http://example.com/post/8615c104.html</id>
    <published>2016-06-07T13:37:02.000Z</published>
    <updated>2023-12-02T10:27:22.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>通过<a href="http://lzascott.github.io/2016/06/06/ReactiveCocoa-%E4%B8%80/">ReactiveCocoa(一)</a>的学习，相信大家对ReactiveCocoa有了一些基本认识吧。下面就让我们来学习ReactiveCocoa的一些基本使用吧！</p><span id="more"></span><h2 id="二、ReactiveCocoa基本使用"><a href="#二、ReactiveCocoa基本使用" class="headerlink" title="二、ReactiveCocoa基本使用"></a>二、ReactiveCocoa基本使用</h2><h3 id="2-1-代替代理"><a href="#2-1-代替代理" class="headerlink" title="2.1 代替代理"></a>2.1 代替代理</h3><p>在ReactiveCocoa(一)中讲到可以通过<code>RACSubject</code>代替代理，我们也可以通过<code>rac_signalForSelector</code>同样代替代理。</p><h4 id="2-1-1-代码演练"><a href="#2-1-1-代码演练" class="headerlink" title="2.1.1 代码演练"></a>2.1.1 代码演练</h4><pre><code>// 需求：自定义redView,监听红色view中按钮点击// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。[[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;    NSLog(@&quot;点击红色按钮&quot;);&#125;];</code></pre><h3 id="2-2-代替KVO"><a href="#2-2-代替KVO" class="headerlink" title="2.2 代替KVO"></a>2.2 代替KVO</h3><p><code>rac_valuesAndChangesForKeyPath:</code>用于监听某个对象的某个属性发生变化。</p><h4 id="2-2-1-代码演练"><a href="#2-2-1-代码演练" class="headerlink" title="2.2.1 代码演练"></a>2.2.1 代码演练</h4><pre><code>// 需求:每点击一次，年龄增加一次// 定义一个age属性- (void)obserVer &#123;    [[self rac_valuesForKeyPath:@&quot;age&quot; observer:nil] subscribeNext:^(id x) &#123;        NSLog(@&quot;%@&quot;,x);    &#125;];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;    self.age ++;&#125;</code></pre><h3 id="2-3-监听事件"><a href="#2-3-监听事件" class="headerlink" title="2.3 监听事件"></a>2.3 监听事件</h3><p><code>rac_signalForControlEvents:</code>用于监听某个事件。</p><h4 id="2-3-1-代码演练"><a href="#2-3-1-代码演练" class="headerlink" title="2.3.1 代码演练"></a>2.3.1 代码演练</h4><pre><code>// 把按钮点击事件转化成信号，点击按钮，就会发送信号[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;        NSLog(@&quot;监听按钮点击事件&quot;); &#125;];</code></pre><h3 id="2-4-代替通知"><a href="#2-4-代替通知" class="headerlink" title="2.4 代替通知"></a>2.4 代替通知</h3><p><code>rac_addObserverForName:</code>用于监听某个通知。</p><h4 id="2-4-1-代码演练"><a href="#2-4-1-代码演练" class="headerlink" title="2.4.1 代码演练"></a>2.4.1 代码演练</h4><pre><code>[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) &#123;    NSLog(@&quot;弹出键盘&quot;);&#125;];</code></pre><h3 id="2-5-监听文本框文字改变"><a href="#2-5-监听文本框文字改变" class="headerlink" title="2.5 监听文本框文字改变"></a>2.5 监听文本框文字改变</h3><p><code>rac_textSignal:</code>用于监听文本框文字发生改变</p><h4 id="2-5-1-代码演练"><a href="#2-5-1-代码演练" class="headerlink" title="2.5.1 代码演练"></a>2.5.1 代码演练</h4><pre><code>[[self.textField rac_textSignal] subscribeNext:^(id x) &#123;    NSLog(@&quot;text:%@&quot;,x);&#125;];</code></pre><h3 id="2-6-处理当界面有多个请求时，需要都获取到数据，才能展示界面"><a href="#2-6-处理当界面有多个请求时，需要都获取到数据，才能展示界面" class="headerlink" title="2.6 处理当界面有多个请求时，需要都获取到数据，才能展示界面"></a>2.6 处理当界面有多个请求时，需要都获取到数据，才能展示界面</h3><p><code>rac_liftSelector:withSignalsFromArray:Signals:</code>当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发selector参数的方法。</p><p><strong>注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据，否则运行时会报错。</strong></p><h4 id="2-6-1-代码演练"><a href="#2-6-1-代码演练" class="headerlink" title="2.6.1 代码演练"></a>2.6.1 代码演练</h4><pre><code>- (void)test&#123;    // 创建信号A    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;            NSLog(@&quot;数据请求1&quot;);            [subscriber sendNext:@&quot;发送请求1回来的数据&quot;];            return [RACDisposable disposableWithBlock:^&#123;                NSLog(@&quot;随便写写&quot;);            &#125;];        &#125;];        // 创建信号B    RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;        NSLog(@&quot;数据请求2&quot;);        [subscriber sendNext:@&quot;发送请求2回来的数据&quot;];        return nil;    &#125;];        // RAC:就可以判断两个信号有没有都发出内容    // SignalsFromArray:监听哪些信号的发出    // 当signals数组中的所有信号都发送sendNext就会触发方法调用者(self)的selector    // 注意:selector方法的参数不能乱写,有几个信号就对应几个参数    // 不需要主动订阅signalA,signalB,方法内部会自动订阅    [self rac_liftSelector:@selector(doneNextWithA:andB:) withSignalsFromArray:@[signalA,signalB]];&#125;- (void)doneNextWithA:(NSString *)a andB:(NSString *)b &#123;        NSLog(@&quot;请求完成，更新UI--a:%@,b:%@&quot;,a,b);&#125;</code></pre><h2 id="三、ReactiveCocoa常见宏"><a href="#三、ReactiveCocoa常见宏" class="headerlink" title="三、ReactiveCocoa常见宏"></a>三、ReactiveCocoa常见宏</h2><h3 id="3-1-RAC-TARGET-…"><a href="#3-1-RAC-TARGET-…" class="headerlink" title="3.1 RAC(TARGET, …)"></a>3.1 RAC(TARGET, …)</h3><ul><li>用于给某个对象的某个属性绑定。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只要文本框文字改变，就会修改label的文字</span><br><span class="line">   RAC(self.labelView,text) = _textField.rac_textSignal;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-RACObserve-TARGET-KEYPATH"><a href="#3-2-RACObserve-TARGET-KEYPATH" class="headerlink" title="3.2 RACObserve(TARGET,KEYPATH)"></a>3.2 RACObserve(TARGET,KEYPATH)</h3><ul><li>监听某个对象的某个属性，返回的是信号  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(self, age) subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-weakify-Obj-和-strongify-Obj"><a href="#3-3-weakify-Obj-和-strongify-Obj" class="headerlink" title="3.3 @weakify(Obj)和@strongify(Obj)"></a>3.3 @weakify(Obj)和@strongify(Obj)</h3><ul><li>一般都是成对出现，为了避免引起循环引用导致内存泄漏的，和block的使用类似。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">   [[_redView rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) &#123;</span><br><span class="line">       @strongify(self);</span><br><span class="line">       NavViewController *navVC = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil] instantiateViewControllerWithIdentifier:NSStringFromClass([NavViewController class])];</span><br><span class="line">       [self.navigationController pushViewController:navVC animated:YES];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-RACTuplePack"><a href="#3-4-RACTuplePack" class="headerlink" title="3.4 RACTuplePack"></a>3.4 RACTuplePack</h3><ul><li>把数据包装成RACTuple（元组类）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 把参数中的数据包装成元组</span><br><span class="line">  RACTuple *tuple = RACTuplePack(@&quot;Scott_Mr&quot;,@20);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-RACTupleUnpack"><a href="#3-5-RACTupleUnpack" class="headerlink" title="3.5 RACTupleUnpack"></a>3.5 RACTupleUnpack</h3><ul><li>把RACTuple（元组类）解包成对应的数据。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span><br><span class="line">   // name = @&quot;Scott_Mr&quot; age = @20</span><br><span class="line">   RACTupleUnpack(NSString *name,NSNumber *age) = tuple;</span><br><span class="line">   NSLog(@&quot;%@,%@&quot;,name,age);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;通过&lt;a href=&quot;http://lzascott.github.io/2016/06/06/ReactiveCocoa-%E4%B8%80/&quot;&gt;ReactiveCocoa(一)&lt;/a&gt;的学习，相信大家对ReactiveCocoa有了一些基本认识吧。下面就让我们来学习ReactiveCocoa的一些基本使用吧！&lt;/p&gt;</summary>
    
    
    
    <category term="ReactiveCocoa" scheme="http://example.com/categories/ReactiveCocoa/"/>
    
    
    <category term="ReactiveCocoa" scheme="http://example.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa(一)</title>
    <link href="http://example.com/post/29245a66.html"/>
    <id>http://example.com/post/29245a66.html</id>
    <published>2016-06-06T15:32:32.000Z</published>
    <updated>2023-12-02T10:27:22.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>之前总听别人说什么Reactive Cocoa + MVVM，但是没有找到讲解Reactive Cocoa相关的资料。结果进入新公司，项目里面有部分代码使用到了Reactive Cocoa,所以笔者在这记录自己学习Reactive Cocoa的笔记，同时也希望大家通过阅读这篇文章能学到点什么。</p><span id="more"></span><h2 id="二、Reactive-Cocoa简介"><a href="#二、Reactive-Cocoa简介" class="headerlink" title="二、Reactive Cocoa简介"></a>二、Reactive Cocoa简介</h2><p>Reactive Cocoa(简称RAC，PS:<strong>不是ARC(自动引用计数)</strong>),是由Github开源的一个应用于iOS和OS开发的新框架，cocoa是苹果整套框架的简称，因此很多苹果框架都喜欢以cocoa结尾。</p><h2 id="三、Reactive-Cocoa作用"><a href="#三、Reactive-Cocoa作用" class="headerlink" title="三、Reactive Cocoa作用"></a>三、Reactive Cocoa作用</h2><ul><li>在我们iOS开发中，当某些事件响应的时候，需要处理某些业务逻辑，这些事情都以不同的方式来处理。</li><li>我们之前熟悉的事件处理方式有：action、delegate、kvo、block以及notification。其实这些事件都可以使用RAC处理。</li><li>RAC为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把需要处理的事件和监听事件的代码放到一块，这样便于我们管理，就不需要跳转到对应的方法里面。非常符合我们开发中<strong>高聚合，低耦合</strong>的思想。</li></ul><h2 id="四、编程思想"><a href="#四、编程思想" class="headerlink" title="四、编程思想"></a>四、编程思想</h2><p>在开发过程中我们要学习一个框架，还是有必要先了解它的<strong>编程思想</strong>。</p><p>先了解一下我们已知的编程思想：</p><p><strong>1、面向过程</strong>: 处理事情以过程为中心，一步一步的实现。</p><p><strong>2、面向对象</strong>: 万物皆对象。</p><p><strong>3、链式编程</strong>: 是将多个操作通过点号(.)连接起来成为一句代码，使代码可读性好。如：</p><pre><code>add(1).add(2).add(3) </code></pre><p>链式编程特点: 方法的返回值是block，block必须有返回值(对象本身),block参数就是我们要操作的值</p><ul><li>代表作: masonry框架</li></ul><p>模仿masonry框架，仿写一个加法计算器，练习链式编程思想</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个NSObject的分类,  .h代码：</span><br><span class="line">@class CaculatorMaker;</span><br><span class="line">@interface NSObject (Caculator)</span><br><span class="line"></span><br><span class="line">+ (int)makeCaculator:(void(^)(CaculatorMaker *make))caculator;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// .m代码</span><br><span class="line">@implementation NSObject (Caculator)</span><br><span class="line"></span><br><span class="line">+ (int)makeCaculator:(void(^)(CaculatorMaker *make))caculator &#123;</span><br><span class="line">CaculatorMaker *maker = [[CaculatorMaker alloc] init];</span><br><span class="line"></span><br><span class="line">caculator(maker);</span><br><span class="line"></span><br><span class="line">return maker.result;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**********************************************************/</span><br><span class="line"></span><br><span class="line">//创建一个CaculatorMaker类， .h代码：</span><br><span class="line">@interface CaculatorMaker : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int result;</span><br><span class="line"></span><br><span class="line">- (CaculatorMaker *(^)(int result))add;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">//.m代码</span><br><span class="line">- (CaculatorMaker *(^)(int result))add &#123;</span><br><span class="line">     return ^(int result)&#123;</span><br><span class="line">        _result += result;</span><br><span class="line">        return self;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//调用：</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">int result = [NSObject makeCaculator:^(CaculatorMaker *make) &#123;</span><br><span class="line">make.add(1).add(3);</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;%d&quot;,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、响应式编程</strong>:不需要考虑调用顺序，只需要考虑调用结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件就像流一样发送出去，最后影响结果。</p><ul><li>代表作: KVO的运用</li></ul><p><strong>5、函数式编程</strong>:是把操作尽量使用一系列的函数或者方法调用</p><ul><li>函数式编程特点: 每个方法必须有返回值(对象本身)，把block当做参数，block参数就是需要操作的值，block返回值就是操作结果</li></ul><p>使用函数式编程实现一个加法计算器并自带判断是否等于某个值的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//创建一个CaculatorMaker类，.h代码：</span><br><span class="line">@interface CaculatorMaker : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int result;</span><br><span class="line">@property (nonatomic, assign, getter=isEqual) BOOL equal;</span><br><span class="line"></span><br><span class="line">- (CaculatorMaker *)add:(int(^)(int result))caculator;</span><br><span class="line">- (CaculatorMaker *)equal:(BOOL(^)(int result))caculator;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//.m代码：</span><br><span class="line">@implementation CaculatorMaker</span><br><span class="line"></span><br><span class="line">- (CaculatorMaker *)add:(int(^)(int result))caculator &#123;</span><br><span class="line">_result = caculator(_result);</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CaculatorMaker *)equal:(BOOL(^)(int result))caculator &#123;</span><br><span class="line">_equal = caculator(_result);</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//调用:</span><br><span class="line">CaculatorMaker *maker = [[CaculatorMaker alloc] init];</span><br><span class="line">BOOL isEqual = [[[maker add:^int(int result) &#123;</span><br><span class="line">result += 5;</span><br><span class="line">return result;</span><br><span class="line">&#125;] equal:^BOOL(int result) &#123;</span><br><span class="line">return result == 5;</span><br><span class="line">&#125;] isEqual];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%d&quot;,isEqual);</span><br></pre></td></tr></table></figure><p><strong>Reactive Cocoa编程思想</strong></p><p>Reactive Cocoa结合了几种编程思想:</p><ul><li><strong>响应式编程思想</strong></li><li><strong>函数式编程思想</strong></li></ul><p>所以，你有可能听说Reactive Cocoa被描述为<strong>函数响应式编程(FRP)<strong>。<br>    以后使用Reactive Cocoa解决问题时，就不需要考虑调用顺序，直接考虑结果，把每次操作都写成一系列嵌套方法或者函数，使代码</strong>高聚合</strong>，易于管理。</p><h2 id="五、Reactive-Cocoa基础类"><a href="#五、Reactive-Cocoa基础类" class="headerlink" title="五、Reactive Cocoa基础类"></a>五、Reactive Cocoa基础类</h2><p>个人认为在Reactive Cocoa中最核心的类就是<code>RACSignal</code>,搞定这个类基本就可以使用Reactive Cocoa开发了。</p><h3 id="5-1-RACSignal"><a href="#5-1-RACSignal" class="headerlink" title="5.1 RACSignal"></a>5.1 RACSignal</h3><p><code>RACSignal:</code>信号类，一般表示将来有数据传递，只要数据改变，信号内部接收到数据，就会马上发出数据。</p><h4 id="5-1-1-RACSignal简单使用："><a href="#5-1-1-RACSignal简单使用：" class="headerlink" title="5.1.1 RACSignal简单使用："></a>5.1.1 RACSignal简单使用：</h4><pre><code>// RACSignal使用步骤：// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe// 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 3.发送信号 - (void)sendNext:(id)value// RACSignal底层实现：// 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。// 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock// 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。// 2.1 subscribeNext内部会调用siganl的didSubscribe// 3.siganl的didSubscribe中调用[subscriber sendNext:@1];// 3.1 sendNext底层其实就是执行subscriber的nextBlock// 1.创建信号RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;    // block调用时刻：每当有订阅者订阅信号，就会调用block。    // 3.发送信号    [subscriber sendNext:@1];    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。    [subscriber sendCompleted];    return [RACDisposable disposableWithBlock:^&#123;        // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。        // 执行完Block后，当前信号就不在被订阅了。        NSLog(@&quot;信号被销毁&quot;);    &#125;];&#125;];// 2.订阅信号,才会激活信号.[siganl subscribeNext:^(id x) &#123;    // block调用时刻：每当有信号发出数据，就会调用block.    NSLog(@&quot;接收到数据:%@&quot;,x);&#125;];</code></pre><p><strong>注意：</strong></p><ul><li>信号类(RACSignal),只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者发送出去。</li><li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li><li>如何订阅信号：调用信号类<code>RACSignal</code>的<code>subscribeNext</code>就能订阅。</li></ul><h3 id="5-2-RACSubscriber"><a href="#5-2-RACSubscriber" class="headerlink" title="5.2 RACSubscriber"></a>5.2 RACSubscriber</h3><p><code>RACSubscriber:</code>表示订阅者的意思,用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p><h3 id="5-3-RACDisposable"><a href="#5-3-RACDisposable" class="headerlink" title="5.3 RACDisposable"></a>5.3 RACDisposable</h3><p><code>RACDisposable:</code>用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p><ul><li>使用场景：当不想监听某个信号时，可以通过它来主动取消订阅信号</li></ul><h3 id="5-4-RACSubject"><a href="#5-4-RACSubject" class="headerlink" title="5.4 RACSubject"></a>5.4 RACSubject</h3><p><code>RACSubject:</code>信号提供者，自己可以充当信号，又可以发送信号。</p><ul><li>使用场景：通常用来代替代理，有了它，就不需要定义代理了</li></ul><h4 id="5-4-1-RACSubject简单使用"><a href="#5-4-1-RACSubject简单使用" class="headerlink" title="5.4.1 RACSubject简单使用"></a>5.4.1 RACSubject简单使用</h4><pre><code>// RACSubject使用步骤// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 3.发送信号 sendNext:(id)value// RACSubject:底层实现和RACSignal不一样。// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。// 1.创建信号RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123;    // block调用时刻：当信号发出新值，就会调用.    NSLog(@&quot;第一个订阅者%@&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123;    // block调用时刻：当信号发出新值，就会调用.    NSLog(@&quot;第二个订阅者%@&quot;,x);&#125;];// 3.发送信号[subject sendNext:@&quot;1&quot;];</code></pre><h4 id="5-4-2-RACSubject代替代理"><a href="#5-4-2-RACSubject代替代理" class="headerlink" title="5.4.2 RACSubject代替代理"></a>5.4.2 RACSubject代替代理</h4><pre><code> // 需求:// 1.给当前控制器添加一个按钮，modal到另一个控制器界面// 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器步骤一：在第二个控制器.h，添加一个RACSubject代替代理。@interface TwoViewController : UIViewController@property (nonatomic, strong) RACSubject *delegateSignal;@end步骤二：监听第二个控制器按钮点击@implementation TwoViewController- (IBAction)notice:(id)sender &#123;// 通知第一个控制器，告诉它，按钮被点了 // 通知代理 // 判断代理信号是否有值if (self.delegateSignal) &#123;    // 有值，才需要通知    [self.delegateSignal sendNext:nil];&#125;&#125;@end步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.@implementation OneViewController - (IBAction)btnClick:(id)sender &#123;// 创建第二个控制器TwoViewController *twoVc = [[TwoViewController alloc] init];// 设置代理信号twoVc.delegateSignal = [RACSubject subject];// 订阅代理信号[twoVc.delegateSignal subscribeNext:^(id x) &#123;    NSLog(@&quot;点击了通知按钮&quot;);&#125;];// 跳转到第二个控制器[self presentViewController:twoVc animated:YES completion:nil];&#125;@end</code></pre><h3 id="5-5-RACReplaySubject"><a href="#5-5-RACReplaySubject" class="headerlink" title="5.5 RACReplaySubject"></a>5.5 RACReplaySubject</h3><p><code>RACReplaySubject:</code>重复提供信号类，<code>RACSubject</code>的子类。</p><ul><li><code>RACReplaySubject</code>与<code>RACSubject</code>区别：<code>RACReplaySubject</code>可以先发送信号，在订阅信号，<code>RACSubject</code>就不可以。</li><li>使用场景一：如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li><li>使用场景二：可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</li></ul><h5 id="5-5-1-RACReplaySubject简单使用"><a href="#5-5-1-RACReplaySubject简单使用" class="headerlink" title="5.5.1 RACReplaySubject简单使用"></a>5.5.1 RACReplaySubject简单使用</h5><pre><code>// RACReplaySubject使用步骤:// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.可以先订阅信号，也可以先发送信号。// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 2.2 发送信号 sendNext:(id)value// RACReplaySubject:底层实现和RACSubject不一样。// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。// 也就是先保存值，在订阅值。// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 3.订阅信号[replaySubject subscribeNext:^(id x) &#123;    NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);&#125;];// 订阅信号[replaySubject subscribeNext:^(id x) &#123;    NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);&#125;];</code></pre><h3 id="5-6-RACTuple"><a href="#5-6-RACTuple" class="headerlink" title="5.6 RACTuple"></a>5.6 RACTuple</h3><p><code>RACTuple:</code>元组类,类似NSArray,用来包装值.</p><h3 id="5-7-RACSequence"><a href="#5-7-RACSequence" class="headerlink" title="5.7 RACSequence"></a>5.7 RACSequence</h3><p><code>RACSequence:</code>RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p><ul><li>使用场景：字典转模型</li></ul><h4 id="5-7-1-RACSequence和RACTuple简单使用："><a href="#5-7-1-RACSequence和RACTuple简单使用：" class="headerlink" title="5.7.1 RACSequence和RACTuple简单使用："></a>5.7.1 <code>RACSequence</code>和<code>RACTuple</code>简单使用：</h4><pre><code>// 1.遍历数组NSArray *numbers = @[@1,@2,@3,@4];// 这里其实是三步// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;    NSLog(@&quot;%@&quot;,x);&#125;];// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;xmg&quot;,@&quot;age&quot;:@18&#125;;[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;    // 解包元组，会把元组的值，按顺序给参数里面的变量赋值    RACTupleUnpack(NSString *key,NSString *value) = x;    // 相当于以下写法//        NSString *key = x[0];//        NSString *value = x[1];    NSLog(@&quot;%@ %@&quot;,key,value);&#125;];// 3.字典转模型// 3.1 OC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *items = [NSMutableArray array];for (NSDictionary *dict in dictArr) &#123;    FlagItem *item = [FlagItem flagWithDict:dict];    [items addObject:item];&#125;// 3.2 RAC写法NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *flags = [NSMutableArray array];_flags = flags;// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。[dictArr.rac_sequence.signal subscribeNext:^(id x) &#123;    // 运用RAC遍历字典，x：字典    FlagItem *item = [FlagItem flagWithDict:x];    [flags addObject:item];&#125;];NSLog(@&quot;%@&quot;,  NSStringFromCGRect([UIScreen mainScreen].bounds));// 3.3 RAC高级写法:NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];// map:映射的意思，目的：把原始值value映射成一个新值// array: 把集合转换成数组// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。NSArray *flags = [[dictArr.rac_sequence map:^id(id value) &#123;    return [FlagItem flagWithDict:value];&#125;] array];</code></pre><h3 id="5-8-RACCommand"><a href="#5-8-RACCommand" class="headerlink" title="5.8 RACCommand"></a>5.8 RACCommand</h3><p><code>RACCommand:</code>RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</p><ul><li>使用场景：监听按钮点击，网络请求</li></ul><h4 id="5-8-1-RACCommand简单使用"><a href="#5-8-1-RACCommand简单使用" class="headerlink" title="5.8.1 RACCommand简单使用"></a>5.8.1 RACCommand简单使用</h4><pre><code> // 一、RACCommand使用步骤:// 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock// 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值// 3.执行命令 - (RACSignal *)execute:(id)input// 二、RACCommand使用注意:// 1.signalBlock必须要返回一个信号，不能传nil.// 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];// 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。// 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。// 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。// 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。// 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。// 四、如何拿到RACCommand中返回信号发出的数据。// 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。// 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。// 五、监听当前命令是否正在执行executing// 六、使用场景,监听按钮点击，网络请求// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;    NSLog(@&quot;执行命令&quot;);    // 创建空信号,必须返回信号    //        return [RACSignal empty];    // 2.创建信号,用来传递数据    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;        [subscriber sendNext:@&quot;请求数据&quot;];        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。        [subscriber sendCompleted];        return nil;    &#125;];&#125;];// 强引用命令，不要被销毁，否则接收不到数据_conmmand = command;// 3.订阅RACCommand中的信号[command.executionSignals subscribeNext:^(id x) &#123;    [x subscribeNext:^(id x) &#123;        NSLog(@&quot;%@&quot;,x);    &#125;];&#125;];// RAC高级用法// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号[command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;    NSLog(@&quot;%@&quot;,x);&#125;];// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。[[command.executing skip:1] subscribeNext:^(id x) &#123;    if ([x boolValue] == YES) &#123;        // 正在执行        NSLog(@&quot;正在执行&quot;);    &#125;else&#123;        // 执行完成        NSLog(@&quot;执行完成&quot;);    &#125;&#125;];   // 5.执行命令[self.conmmand execute:@1];</code></pre><h3 id="5-9-RACMulticastConnection"><a href="#5-9-RACMulticastConnection" class="headerlink" title="5.9 RACMulticastConnection"></a>5.9 RACMulticastConnection</h3><p><code>RACMulticastConnection:</code>用于当一个信号被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p><p><strong>使用注意：</strong>RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建。</p><h4 id="5-9-1-RACMulticastConnection简单使用"><a href="#5-9-1-RACMulticastConnection简单使用" class="headerlink" title="5.9.1 RACMulticastConnection简单使用"></a>5.9.1 RACMulticastConnection简单使用</h4><pre><code>// RACMulticastConnection使用步骤:// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe// 2.创建连接 RACMulticastConnection *connect = [signal publish];// 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]// 4.连接 [connect connect]// RACMulticastConnection底层原理:// 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject// 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。// 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject// 3.1.订阅原始信号，就会调用原始信号中的didSubscribe// 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext// 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。// 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock// 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。// 解决：使用RACMulticastConnection就能解决.// 1.创建请求信号   RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;    NSLog(@&quot;发送请求&quot;);    return nil;&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123;    NSLog(@&quot;接收数据&quot;);&#125;];// 2.订阅信号[signal subscribeNext:^(id x) &#123;    NSLog(@&quot;接收数据&quot;);&#125;];// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求// RACMulticastConnection:解决重复请求问题// 1.创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;    NSLog(@&quot;发送请求&quot;);    [subscriber sendNext:@1];    return nil;&#125;];// 2.创建连接RACMulticastConnection *connect = [signal publish];// 3.订阅信号，// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:[connect.signal subscribeNext:^(id x) &#123;    NSLog(@&quot;订阅者一信号&quot;);&#125;];[connect.signal subscribeNext:^(id x) &#123;    NSLog(@&quot;订阅者二信号&quot;);&#125;];// 4.连接,激活信号[connect connect];</code></pre><h3 id="5-10-RACScheduler"><a href="#5-10-RACScheduler" class="headerlink" title="5.10 RACScheduler"></a>5.10 RACScheduler</h3><p><code>RACScheduler:</code>RAC中的队列，用GCD封装的。</p><h3 id="5-11-RACUnit"><a href="#5-11-RACUnit" class="headerlink" title="5.11 RACUnit"></a>5.11 RACUnit</h3><p><code>RACUnit:</code>表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil。</p><h3 id="5-12-RACEvent"><a href="#5-12-RACEvent" class="headerlink" title="5.12 RACEvent"></a>5.12 RACEvent</h3><p><code>RACEvent:</code>把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;之前总听别人说什么Reactive Cocoa + MVVM，但是没有找到讲解Reactive Cocoa相关的资料。结果进入新公司，项目里面有部分代码使用到了Reactive Cocoa,所以笔者在这记录自己学习Reactive Cocoa的笔记，同时也希望大家通过阅读这篇文章能学到点什么。&lt;/p&gt;</summary>
    
    
    
    <category term="ReactiveCocoa" scheme="http://example.com/categories/ReactiveCocoa/"/>
    
    
    <category term="ReactiveCocoa" scheme="http://example.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>nil、Nil、NULL、NSNull的理解</title>
    <link href="http://example.com/post/937a3ecd.html"/>
    <id>http://example.com/post/937a3ecd.html</id>
    <published>2016-06-06T15:22:30.000Z</published>
    <updated>2023-12-02T10:27:22.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在工作当中我们在调用官方的api的时候，有时候一个参数即可以写成<code>nil</code>，而写成<code>NULL</code>也不会报错。也是一直没有搞明白为什么。然后通过查阅资料，发现原来除了<code>nil</code>,<code>NULL</code>,还有<code>Nil</code>,<code>NSNull</code>，是不是感觉很晕，我也是懵逼了。于是做一下笔记记录一下。</p><span id="more"></span><h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>我们给对象赋值时一般都会使用<code>object = nil</code>,表示我想把这个对象释放掉；</p><p>或者对象由于某种原因，经过多次release，于是对象引用计数为0了，系统将这块内存释放掉，这个时候这个对象为nil,我们称它为<strong>“空对象”</strong>。（**注意：这里强调的是“空对象”，下面我会拿它和“值为空的对象”做对比!**）</p><p>所以对于这种空对象，所有关于retain的操作都会引起程序crash(<strong>注意:我是说关于retain操作，而向一个nil对象发送消息是不会crash的</strong>),例如字典添加键值或者数组添加新元素等，具体可以参考如下代码：</p><pre><code>- (void)viewDidLoad &#123;    [super viewDidLoad];    NSMutableArray *mArr = [[NSMutableArray alloc] init];    NSMutableDictionary *mDic = [[NSMutableDictionary alloc] init];        // 以下用法不会引起crash//    id object = [[NSObject alloc] init];//    [mArr addObject:object];//    [mDic setObject:object forKey:@&quot;objectKey&quot;];            // 以下用法会导致crash    id obj = nil;    [mArr addObject:obj];    [mDic setObject:obj forKey:@&quot;objKey&quot;];    &#125;</code></pre><h2 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h2><p><code>NSNull</code>和<code>nil</code>的区别在于<code>nil</code>是一个空对象，已经完全从内存中消失了，而如果我们想表达“我们需要有这样一个容器，但是这个容器里面什么也没有”的时候，我们就要用到<code>NSNull</code>，我称它为”值为空的对象”。如果你查阅开发文档你会发现<code>NSNull</code>这个类是继承<code>NSObject</code>，并且只有一个<code>+ (NSNull *) null;</code>类方法。这就说明<code>NSNull</code>对象拥有一个有效的内存地址，所以在程序中对它的任何引用都是不会导致程序崩溃的。参考代码如下：</p><pre><code>- (void)viewDidLoad &#123;    [super viewDidLoad];    NSMutableArray *mArr = [[NSMutableArray alloc] init];    NSMutableDictionary *mDic = [[NSMutableDictionary alloc] init];        id obj = nil;    if (obj == nil) &#123;        obj = [NSNull null];    &#125;        [mArr addObject:obj];    [mDic setObject:obj forKey:@&quot;objKey&quot;];    NSLog(@&quot;%@--%@&quot;,[mArr firstObject],mDic[@&quot;objKey&quot;]);&#125;</code></pre><h2 id="Nil"><a href="#Nil" class="headerlink" title="Nil"></a>Nil</h2><p><code>Nil</code>和<code>nil</code>在使用上没有严格规定的，也就是说凡是使用<code>nil</code>的地方都可以使用<code>Nil</code>来代替，反之亦然。只不过从编程命名规范来说，我们约定俗成地将<code>Nil</code>表示成一个空类，<code>nil</code>表示一个空对象。参考代码如下:</p><pre><code>- (void)viewDidLoad &#123;    [super viewDidLoad];    id obj = nil;    if (obj == nil) &#123;        NSLog(@&quot;obj is nil&quot;);    &#125;        Class classA = Nil;    if (classA == Nil) &#123;        NSLog(@&quot;classA is Nil&quot;);    &#125;&#125;</code></pre><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>我们知道<code>Object-C</code>来源于C、支持C，当然也有别于C，而<code>NULL</code>就是典型C语言的语法，它表示一个空指针，参考代码如下：</p><pre><code>NSInteger *point = NULL;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在工作当中我们在调用官方的api的时候，有时候一个参数即可以写成&lt;code&gt;nil&lt;/code&gt;，而写成&lt;code&gt;NULL&lt;/code&gt;也不会报错。也是一直没有搞明白为什么。然后通过查阅资料，发现原来除了&lt;code&gt;nil&lt;/code&gt;,&lt;code&gt;NULL&lt;/code&gt;,还有&lt;code&gt;Nil&lt;/code&gt;,&lt;code&gt;NSNull&lt;/code&gt;，是不是感觉很晕，我也是懵逼了。于是做一下笔记记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS开发" scheme="http://example.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>两个App之间调起通信</title>
    <link href="http://example.com/post/a47a005e.html"/>
    <id>http://example.com/post/a47a005e.html</id>
    <published>2016-06-05T15:24:34.000Z</published>
    <updated>2023-12-02T10:27:22.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常使用一些app的分享功能，比如点击QQ分享，就从app打开(跳转到)QQ，然后分享完之后又回到我们的app，那么这是怎样实现的呢？</p><span id="more"></span><p>假设有这么一个需求，由app1跳转到app2，当app2完成任务之后，要把app2中的某些信息传到app1中(假设我们自己的程序是app1)</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>我们创建两个新的工程，一个叫Test1，一个叫Test2。</p><p>本篇文章将使用<code>Test1</code>作为第一个app的<code>URL Schemes</code>,<code>Test2</code>作为第二个app的<code>URL Schemes</code>。</p><h3 id="Test1工程配置"><a href="#Test1工程配置" class="headerlink" title="Test1工程配置"></a>Test1工程配置</h3><p>由于iOS9.0之后跳转<code>URL Schemes</code>需要将添加<code>白名单</code><br><img src="http://7xv28v.com1.z0.glb.clouddn.com/app1.png" alt="图1"><br>对于<code>URL Schemes</code>中的Test1是本应用留给其他应用调用的。</p><h3 id="Test2工程配置"><a href="#Test2工程配置" class="headerlink" title="Test2工程配置"></a>Test2工程配置</h3><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/app2.png" alt="图2"><br>对于<code>URL Schemes</code>中的Test2是本应用留给其他应用调用的。</p><h3 id="Test1工程中测试代码"><a href="#Test1工程中测试代码" class="headerlink" title="Test1工程中测试代码"></a>Test1工程中测试代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Test2是在Test2这个项目的info.plist中配置的URL Schemes</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;Test2://&quot;</span>]]) &#123;</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;Test2://success=1&amp;&amp;name=test2&quot;</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application handleOpenURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[url host] stringByRemovingPercentEncoding];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@---%@&quot;</span>,str, url.absoluteString); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先需要判断手机是否安装了应用Test2，通过Test2工程公开的<code>URL Schemes</code>来判断，即<code>Test2://</code>。需要传参数时，是通过URL参数来传的。如：<code>Test2://success=1&amp;&amp;name=test2</code>就是一个URL。</p><h3 id="Test2工程中测试代码"><a href="#Test2工程中测试代码" class="headerlink" title="Test2工程中测试代码"></a>Test2工程中测试代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application handleOpenURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[url host] stringByRemovingPercentEncoding];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@---%@&quot;</span>,str, url.absoluteString); </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(goBackToApp1) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)goBackToApp1 &#123;</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;Test1://&quot;</span>]]) &#123;</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;Test1://loginSuccess=1&quot;</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url</code>处理来自Test1应用的调用，获取到相应的参数了。</p><p>当我们处理数据完成，需要反馈给Test1时，就需要调用通过<code>Test1://loginSuccess=1</code>调用回到Test1并将状态带回去。</p><h3 id="Test1打印日志"><a href="#Test1打印日志" class="headerlink" title="Test1打印日志"></a>Test1打印日志</h3><pre><code>2016-06-05 23:23:09.807 test1[1277:219009] loginSuccess=1---Test1://loginSuccess=1</code></pre><p>说明参数能从Test2正确地传递过来。</p><h3 id="Test2打印日志"><a href="#Test2打印日志" class="headerlink" title="Test2打印日志"></a>Test2打印日志</h3><pre><code>2016-06-05 23:22:15.008 test2[1243:216871] success=1&amp;&amp;name=test2---Test2://success=1&amp;&amp;name=test2</code></pre><p>说明参数能从Test1正确地传递过来。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经常使用一些app的分享功能，比如点击QQ分享，就从app打开(跳转到)QQ，然后分享完之后又回到我们的app，那么这是怎样实现的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="app通信" scheme="http://example.com/categories/app%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>收藏</title>
    <link href="http://example.com/post/89b6cade.html"/>
    <id>http://example.com/post/89b6cade.html</id>
    <published>2016-06-04T09:44:27.000Z</published>
    <updated>2023-12-02T10:27:22.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a href="http://www.cnblogs.com/dsxniubility/p/5099191.html">http://www.cnblogs.com/dsxniubility/p/5099191.html</a></p><h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><p><a href="http://www.cocoachina.com/ios/20150727/12720.html">http://www.cocoachina.com/ios/20150727/12720.html</a></p><span id="more"></span><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><a href="https://github.com/tangqiaoboy/iOSBlogCN">https://github.com/tangqiaoboy/iOSBlogCN</a></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li><a href="https://wangmeng.gitbooks.io/ios-note/content/interview_1.html">面试题</a></li><li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md">招一个靠谱的iOS</a></li></ul><h2 id="常用网址"><a href="#常用网址" class="headerlink" title="常用网址"></a>常用网址</h2><p><a href="https://ioser.org/">https://ioser.org/</a></p><p>不断更新中…</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dsxniubility/p/5099191.html&quot;&gt;http://www.cnblogs.com/dsxniubility/p/5099191.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;类库&quot;&gt;&lt;a href=&quot;#类库&quot; class=&quot;headerlink&quot; title=&quot;类库&quot;&gt;&lt;/a&gt;类库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150727/12720.html&quot;&gt;http://www.cocoachina.com/ios/20150727/12720.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="收藏" scheme="http://example.com/categories/%E6%94%B6%E8%97%8F/"/>
    
    
    <category term="收藏" scheme="http://example.com/tags/%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git从入门到速成</title>
    <link href="http://example.com/post/206bda90.html"/>
    <id>http://example.com/post/206bda90.html</id>
    <published>2016-06-04T05:15:49.000Z</published>
    <updated>2023-12-02T10:27:22.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h2><p>Git是Linux发明者Linus开发的一款新时代的<strong>版本控制系统</strong>，那什么是版本控制系统呢？怎么理解？网上一大堆详细的介绍，但是大多枯燥乏味，对于新手也很难理解，这里我只举几个例子。</p><p>熟悉编程的都知道，我们在软件开发中源代码其实是最重要的，那么对源代码的管理变得异常重要：</p><ul><li>为了防止代码的丢失，肯定本地机器与远程服务器都要存放一份，而且还需要有一套机制让本地可以跟远程同步；</li><li>我们开发的时候免不了有bug，有时候刚发布的功能就出现了严重的bug,这个时候需要对代码进行还原；</li><li>随着我们版本迭代的功能越来越多，但是我们需要清除的知道历史每一个版本的代码更改记录，甚至知道每个人历史提交代码的情况<span id="more"></span>等等类似以上的情况，这些都是版本控制系统能解决的问题。所以说，版本控制是一种记录一个或者若干个文件内容变换，以便将来查阅特定版本修改情况的系统，对于软件开发领域来说版本控制是最重要的一个环节，而Git是当下比较流行、好用的版本控制系统。</li></ul><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>上面说了，Git是一个版本控制系统，你也可以理解成一个工具，跟Java类似，使用之前必须得先安装，所以第一步必须要安装，由于我用的是Mac，Mac上系统自带Git。所以安装这一步骤就省略，相信大家可以搞的定。</p><h2 id="如何学习Git"><a href="#如何学习Git" class="headerlink" title="如何学习Git"></a>如何学习Git</h2><p>安装好Git之后，怎么学习是个问题，其实关于Git有很多图形化的软件，但是我强烈建议大家从命令行开始学习理解，我知道没有接触过命令行的同学内心可能是拒绝的，但是我的亲身实践证明，只有一开始学习命令行，之后你对Git的每一步操作才能理解其意义，而等你熟练之后 ，你想用任何的图形化的软件去操作完全没有问题。</p><h2 id="Git命令列表"><a href="#Git命令列表" class="headerlink" title="Git命令列表"></a>Git命令列表</h2><p>怎么判断你Git有没有安装成功呢？请在命令行里输入git，如果出现以下提示证明你已经安装成功了。</p><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/git1.png" alt="如图"></p><p>Git所有的操作命令都是以git开头，上面列举了最常用的一些Git命令，紧接着会有一句引文解释这个命令的意思，都不是很难理解的单词，不妨试着看一下，不过没有实际操作你仍然不好理解，下面我们来以一个实际的操作来介绍下一些常用的命令的含义。</p><h2 id="Git具体命令"><a href="#Git具体命令" class="headerlink" title="Git具体命令"></a>Git具体命令</h2><p>第一步：我们先新建一个文件夹，在文件夹里新建一个文件(ps:<strong>我是用命令行去新建的</strong>)</p><ul><li><p>新建文件夹：<code>mkdir test</code></p></li><li><p>跳转到文件夹目录：<code>cd test</code></p></li><li><p>新建test.md文件: <code>touch test.md</code></p></li></ul><p><strong>提醒：在进行任何Git操作之前，都要先切换到Git仓库目录，也就是要先切换到项目的文件夹目录下</strong></p><p>这个时候我们先随便操作一个命令，比如git status，可以看到如下提示：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git2.png" alt="如图"></p><p>意思就是当前目录还不是一个Git仓库。</p><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>这个时候用到了第一个命令，代表初始化git仓库，输入git init之后会提示：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git3.png" alt="如图"></p><p>可以看到初始化成功了，至此test目录已经是一个git仓库了。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>紧接着我们输入git status命令，会有如下提示:<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git4.png" alt="如图"></p><p>默认就直接在master分支，关于分支的概念后面会提，这时最主要的是提示test.md这个文件<br><code>Untracked files</code>就是说test.md这个文件还没有被跟踪，还没有提交在git仓库里呢，而且提示你可以用git add去操作你想要提交的文件。</p><p><code>git status</code>这个命令就是查看状态，这个命令可以算是使用最频繁的了，建议大家没事就输入这个命令来查看你当前git仓库的一些状态。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>上面提示test.md文件还没有提交到git仓库里，这个时候我们可以随便编辑下test.md文件，然后输入<code>git add test.md</code>，然后再输入<code>git status</code>：<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git5.png" alt="如图"></p><p>此时提示以下文件 <code>Changes to be committed</code>,意思就是test.md文件等待被提交，当然你也可以使用 <code>git rm -cached</code>这个命令去移除这个缓存。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>接着，我们输入 <code>git commit -m &quot;first commit&quot;</code>，这个命令是什么意思呢？commit是提交的意思，-m 代表提交信息，执行了以上命令代表我们已经正式进行了第一次提交。这个时候再输入 <code>git status</code> ，会提示 <code>nothing to commit</code> 。<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git6.png" alt="图6"></p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>这个时候，我们输入 <code>git log</code>命令，就会看到如下:<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git7.png" alt="图7"></p><p><code>git log</code>这个命令可以查看所有commit产生的记录，所以可以看到已经产生了一条commit记录，而提交时候的附带信息叫 <code>“first commit”</code> 。</p><h3 id="git-add-git-commit"><a href="#git-add-git-commit" class="headerlink" title="git add &amp; git commit"></a>git add &amp; git commit</h3><p>看到这里估计很多人都会有疑问，我想要提交直接进行commit不就行了么为什么需要先add一次呢？首先 <code>git add</code> 是把改动添加到一个<strong>暂存区</strong>，你可以理解成一个缓存区域，临时保存你的改动，而 <code>git commit</code> 才是最后真正的提交，当然也有办法把这两步合并成一步，不过后面再介绍，建议新手先按部就班的一步步来。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>branch即分支的意思，分支的概念很重要，尤其是团队协作的时候，假设两个人都做同一个项目，这个时候分支就是保证两人能协同合作的最大力气了。</p><p>举个🌰：A、B两人都在做同一个项目，但是不同的模块，这个时候A新建了一个分支叫a，B新建了一个分支叫b，这样A、B做的所有代码改动都在各自的分支，互不影响，等到两人都把各自的模块都做完了，最后再统一把分支合并起来。</p><p>执行 <code>git init</code>初始化git仓库之后会默认生成一个主分支master，也是你所在的默认分支，也基本是实际开发正式环境下的分支，一般情况下master分支不会轻易直接在上面操作的，你们可以输入<code>git branch</code>查看下当前分支情况；如果我们想在此基础上新建一个分支呢，很简单，执行 <code>git branch a</code>就新建了一个名字叫a的分支，这时候分支a跟分支master是一模一样的内容，我们再输入<code>git branch</code> 查看当前的分支情况；</p><p>但是可以看到master分支前有个 * 号，(<strong>注意: * 所指的分支代表当前所在的分支</strong>) 即虽然新建了一个 a 的分支，但是当前所在的分支还是在master上，如果我们想在 a 分支上进行开发，首先要先切换到 a 分支上才行，所以下一步要切换分支。<code>git checkout a</code><br>执行这个命令，然后再输入<code>git branch</code>查看分支情况，可以看到当前我们所在的分支已经是a了，这个时候，A同学就可以在他新建的a分支进行写代码了。<br>那就有人说了，我要先新建再切换，未免有点麻烦，有没有一步到位的，答案是肯定的：<br><code>git checkout -b a</code>这个命令代表的意思就是新建一个a分支，并且自动切换到a分支</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>A同学在a分支上代码写完了，并且测试也OK了，准备要上线了，这个时候就需要把他的代码合并到分支master上，然后发布。<code>git merge</code>就是合并分支用到的命令，这对这个情况，需要先做两步:</p><ul><li>第一步是切换到master分支，如果你已经在那就不用切换了</li><li>第二步执行git merge a,意思就是把 a 分支的代码合并过来，不出意外，这个时候 a 分支的代码就顺利合并到master分支来了，为什么说不出意外呢？因为这个时候可能因为产生冲突而导致合并失败。</li></ul><h3 id="git-branch-d"><a href="#git-branch-d" class="headerlink" title="git branch -d"></a>git branch -d</h3><p>有新建分支，那肯定就有删除分支，加入这个分支新建错了，或者a分支的代码已经顺利合并到master分支来了，那么a分支没用了，需要删除，这个时候执行代码 <code>git branch -d a</code><br>就可以把a分支删除了。</p><h3 id="git-branch-D"><a href="#git-branch-D" class="headerlink" title="git branch -D"></a>git branch -D</h3><p>有些时候可能会删除失败，比如如果a分支的代码还没有合并到master分支，你执行 <code>git branch -d a</code>是删除不了的，它会智能的提示你a分支还有未合并的代码，但是如果你非要删除，那就执行 <code>git branch -D a</code>就可以强制删除a分支了。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>我们在客户端开发的时候经常有版本的概念，比如v1.0、v1.1之类的，不同的版本肯定对应不同的代码，所以我们一般要给我们的代码加上标签，这样假设v1.1版本出了一个新bug，但是又不知道v1.0是不是有这个bug，有了标签就可以顺利切换到v1.0的代码，重新打个包测试就知道了。<br>所以如果想要新建一个标签很简单，比如 <code>git tag v1.0</code>就代表我在当前代码状态下新建了一个v1.0的标签，输入 <code>git tag</code>可以查看历史tag记录。</p><p>想要切换到某个tag怎么办？<br>也很简单，执行 <code>git checkout v1.0</code>这样就顺利的切换到v1.0 tag的代码状态了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>OK，以上全是一些最基本的git操作，而且全是在本地环境进行操作的，完全没有涉及到远程仓库。毕竟这篇文章是针对小白的，大神可以忽略。</p><p>附上一张git操作的图<br><img src="http://7xv28v.com1.z0.glb.clouddn.com/git8.png" alt="图8"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是Git&quot;&gt;&lt;a href=&quot;#什么是Git&quot; class=&quot;headerlink&quot; title=&quot;什么是Git&quot;&gt;&lt;/a&gt;什么是Git&lt;/h2&gt;&lt;p&gt;Git是Linux发明者Linus开发的一款新时代的&lt;strong&gt;版本控制系统&lt;/strong&gt;，那什么是版本控制系统呢？怎么理解？网上一大堆详细的介绍，但是大多枯燥乏味，对于新手也很难理解，这里我只举几个例子。&lt;/p&gt;
&lt;p&gt;熟悉编程的都知道，我们在软件开发中源代码其实是最重要的，那么对源代码的管理变得异常重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了防止代码的丢失，肯定本地机器与远程服务器都要存放一份，而且还需要有一套机制让本地可以跟远程同步；&lt;/li&gt;
&lt;li&gt;我们开发的时候免不了有bug，有时候刚发布的功能就出现了严重的bug,这个时候需要对代码进行还原；&lt;/li&gt;
&lt;li&gt;随着我们版本迭代的功能越来越多，但是我们需要清除的知道历史每一个版本的代码更改记录，甚至知道每个人历史提交代码的情况</summary>
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>两个imageView实现图片轮播</title>
    <link href="http://example.com/post/6645abe0.html"/>
    <id>http://example.com/post/6645abe0.html</id>
    <published>2016-04-10T15:12:22.000Z</published>
    <updated>2023-12-02T10:27:22.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在不少的项目中，都会用到图片轮播这个功能，现在网上关于图片轮播的轮子也层出不穷，千奇百怪，笔者根据自己的思路，用两个imageView也实现了图片轮播，这里给大家介绍笔者的主要思路以及大概步骤。</p><span id="more"></span><h2 id="轮播实现步骤"><a href="#轮播实现步骤" class="headerlink" title="轮播实现步骤"></a>轮播实现步骤</h2><h4 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h4><p>最底层是一个UIView,上面有一个UIScrollView和UIPageControl,scrollView上有两个UIImageView,imageView的宽高&#x3D;scrollView的宽高&#x3D;view的宽高</p><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%BD%AE%E6%92%AD1.png" alt="图1"></p><h4 id="轮播原理"><a href="#轮播原理" class="headerlink" title="轮播原理"></a>轮播原理</h4><p>假设轮播控件的宽为x，高为y，我们设置scrollView的contentSize的宽度为3x，并且让scrollView在x方向偏移量为x，即显示中间内容</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scrollView.contentSize = <span class="built_in">CGSizeMake</span>(<span class="number">3</span>x, y);</span><br><span class="line">scrollView.contentOffset = <span class="built_in">CGPointMake</span>(x, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%BD%AE%E6%92%AD2.png" alt="2"></p><p>接下来使用代理方法scrollViewDidScroll来监听scrollView的滚动，定义一个枚举来记录滚动的方向</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, Direction) &#123;</span><br><span class="line">    DirectionNone = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    DirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    DirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 滚动方向</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Direction direction;</span><br><span class="line">- (<span class="type">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> offX = scrollView.contentOffset.x;</span><br><span class="line">    <span class="keyword">self</span>.direction = offX &gt; <span class="keyword">self</span>.width ? DirectionLeft : offX &lt; <span class="keyword">self</span>.width ? DirectionRight : DirectionNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写direction的setter方法，根据滚动方向来设置下一张图片的显示，如果是往左边滚动，那么下一张图片的位置应该在右边，如果是往右滚动，那么下一张图片的位置应该在左边。(ps:<strong>此处应该注意滚动到第一张和最后一张的边界情况</strong>)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 设置滚动方向</span></span><br><span class="line">- (<span class="type">void</span>)setDirection:(Direction)direction &#123;</span><br><span class="line">    <span class="keyword">if</span> (_direction == direction) <span class="keyword">return</span>;</span><br><span class="line">    _direction = direction;</span><br><span class="line">    <span class="keyword">if</span> (_direction == DirectionNone) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (_direction == DirectionRight) &#123; <span class="comment">// 如果是向右滚动</span></span><br><span class="line">        <span class="keyword">self</span>.nextImageView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height);</span><br><span class="line">        <span class="keyword">self</span>.nextIndex = <span class="keyword">self</span>.currentIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.nextIndex &lt; <span class="number">0</span>) <span class="keyword">self</span>.nextIndex = _images.count - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (_direction == DirectionLeft)&#123; <span class="comment">// 如果是向左边滚动</span></span><br><span class="line">        <span class="keyword">self</span>.nextImageView.frame = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetMaxX</span>(_currentImageView.frame), <span class="number">0</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height);</span><br><span class="line">        <span class="keyword">self</span>.nextIndex = (<span class="keyword">self</span>.currentIndex + <span class="number">1</span>) % _images.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.nextImageView.image = <span class="keyword">self</span>.images[<span class="keyword">self</span>.nextIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代理方法scrollViewDidEndDecelerating来监听滚动结束，结束后，会变成以下两种情况：</p><ul><li>左滚之后</li></ul><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%BD%AE%E6%92%AD3.png" alt="图3"></p><ul><li>右滚之后</li></ul><p><img src="http://7xv28v.com1.z0.glb.clouddn.com/%E8%BD%AE%E6%92%AD4.png" alt="图4"></p><p>此时，scrollView的偏移量为0或者2x两种情况，我们通过代码再次将scrollView的偏移量设置为x，并且将nextImageView的图片修改为赋值给currentImageView的图片</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> pauseScroll];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)pauseScroll &#123;</span><br><span class="line">    <span class="comment">// 等于1表示没有滚动</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollView.contentOffset.x / <span class="keyword">self</span>.width == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">self</span>.currentIndex = <span class="keyword">self</span>.nextIndex;</span><br><span class="line">    <span class="keyword">self</span>.pageControl.currentPage = <span class="keyword">self</span>.currentIndex;</span><br><span class="line">    <span class="keyword">self</span>.currentImageView.frame = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.width, <span class="number">0</span>, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height);</span><br><span class="line">    <span class="keyword">self</span>.descLabel.text = <span class="keyword">self</span>.describeArray[<span class="keyword">self</span>.currentIndex];</span><br><span class="line">    <span class="keyword">self</span>.currentImageView.image = <span class="keyword">self</span>.nextImageView.image;</span><br><span class="line">    <span class="keyword">self</span>.scrollView.contentOffset = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.width, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样之后，我们看到的还是currentImageView，只是图片显示的是下一张的图片或者上一张的图片，又回到了最初的样子。</p><h4 id="自动滚动"><a href="#自动滚动" class="headerlink" title="自动滚动"></a>自动滚动</h4><p>轮播的功能实现了，接下来就是添加定时器让它自动滚动了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启定时器</span></span><br><span class="line">- (<span class="type">void</span>)startTimer &#123;</span><br><span class="line">    <span class="comment">// 如果只有一张，直接放回，不需要开启定时器</span></span><br><span class="line">    <span class="keyword">if</span> (_images.count &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果定时器已经开启，则先停止再开启</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.timer) [<span class="keyword">self</span> stopTimer];</span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:_time &lt; <span class="number">1</span> ? DEFAULTTIME : _time target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(nextPage) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下一页</span></span><br><span class="line">- (<span class="type">void</span>)nextPage &#123;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.width * <span class="number">2</span>, <span class="number">0</span>) animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>setContentOffset:animated:方法执行完毕后不会调用scrollview的scrollViewDidEndDecelerating方法，但是会调用scrollViewDidEndScrollingAnimation方法，因此我们要在该方法中调用pauseScroll</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> pauseScroll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拖拽时停止定时器"><a href="#拖拽时停止定时器" class="headerlink" title="拖拽时停止定时器"></a>拖拽时停止定时器</h4><p>当我们手动拖拽的时候，需要停止自动滚动，此时我们只需要关闭定时器就行了，当我们拖拽结束的时候，重新启动定时器</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopTimer];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="type">BOOL</span>)decelerate &#123;</span><br><span class="line">    [<span class="keyword">self</span> startTimer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>在实际开发中，我们很少自动轮播本地的图片，大部分都是服务器获取的图片url,也有可能既有本地图片，又有网络图片，那么该如何加载呢？</p><ol><li>定义一个imageArr用来接收外界传进来的数组(可以是图片，也可以是网络图片路径，可以图片和路径混合)</li><li>定义一个images用来存储图片(只装图片).判断外界传进来的数组，如果是图片，直接添加到images，如果是连接，先添加一张默认的占位图</li><li>定义一个imageDic用来缓存图片的字典，key为图片URL</li><li>定义一个operationDic用来保存下载操作的字典，key为图片URL</li></ol><h4 id="图片缓存策略-SDWebImage的思路"><a href="#图片缓存策略-SDWebImage的思路" class="headerlink" title="图片缓存策略(SDWebImage的思路)"></a>图片缓存策略(SDWebImage的思路)</h4><p>下载图片，先从缓存中取，如果有，则替换之前的占位图片，如果没有，去沙盒中取，如果有，替换占位图片，并添加到缓存中，如果没有，开启异步线程下载</p><h4 id="监听图片点击"><a href="#监听图片点击" class="headerlink" title="监听图片点击"></a>监听图片点击</h4><p>在实际开发中，通常轮播图都有点击图片跳转到对应的内容的操作，因此需要监听图片的点击，提供两种思路：</p><ul><li><p>通过block:</p><blockquote><ol><li>定义一个block给外界</li><li>打开currentImageView的用户交互</li><li>给currentImageView添加一个点击手势</li><li>在点击手势响应方法里面调用block,并传入图片所在的索引</li></ol></blockquote></li><li><p>通过代理：</p><blockquote><ol><li>定义一个协议方法，设置一个代理属性</li><li>打开currentImageView的用户交互</li><li>给currentImageView添加一个点击手势</li><li>在点击手势响应方法里面用代理调用协议方法，</li></ol></blockquote></li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>上面是笔者实现轮播图的思路以及部分代码，需要源码的<a href="https://github.com/LZAscott/ScottPageView">请戳这里</a>,如果在使用中发现有bug，欢迎提出！如果觉得好用，记得献上你的star哦！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在不少的项目中，都会用到图片轮播这个功能，现在网上关于图片轮播的轮子也层出不穷，千奇百怪，笔者根据自己的思路，用两个imageView也实现了图片轮播，这里给大家介绍笔者的主要思路以及大概步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="轮播" scheme="http://example.com/tags/%E8%BD%AE%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>Xcode7免证书真机调试</title>
    <link href="http://example.com/post/10f55270.html"/>
    <id>http://example.com/post/10f55270.html</id>
    <published>2015-10-26T06:09:46.000Z</published>
    <updated>2023-12-02T10:27:22.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Xcode7正式发布的日子里，苹果给开发者带来了一次惊天的变化，从此开发者不需要花99刀购买开发者证书就能够进行真机调试了，当然如果想要发布到App store那肯定是需要购买的。但是这对于正在学习阶段或者想做一个属于自己APP的同学来说，已经是丰厚的福利了。</p><span id="more"></span><p>接下来我们来配置怎么使用免证书真机调试：</p><ol><li><p>需要一个Apple ID（如果没有，请注册一个申请<a href="https://appleid.apple.com/cn">Apple ID</a>）,一个iPhone手机(如果没有就关闭该文章)和Xcode7(如果没有上App store下载) 。</p></li><li><p>打开Xcode 选择屏幕左上角Xcode-&gt; preferencese(快捷键：command+逗号 两个键)<br> <img src="http://7xv28v.com1.z0.glb.clouddn.com/%E5%85%8D%E8%AF%81%E4%B9%A6%E8%B0%83%E8%AF%951.png" alt="图1"></p></li><li><p>选择Accounts，点击左下角+按钮登陆Apple ID<br> <img src="http://7xv28v.com1.z0.glb.clouddn.com/%E5%85%8D%E8%AF%81%E4%B9%A6%E8%B0%83%E8%AF%952.png" alt="图2"></p></li><li><p>登陆你的Apple ID账号，填完账号密码之后点击Add。<br> <img src="http://7xv28v.com1.z0.glb.clouddn.com/%E5%85%8D%E8%AF%81%E4%B9%A6%E8%B0%83%E8%AF%953.png" alt="图3"></p><p> 登陆成功之后，在右侧会显示你的账号在iOS和Mac上都是free的，双击这一列（或者点击选择view details）<br> <img src="http://7xv28v.com1.z0.glb.clouddn.com/%E5%85%8D%E8%AF%81%E4%B9%A6%E8%B0%83%E8%AF%954.png" alt="图4"></p></li><li><p>这里需要一定时间获取你的Apple ID的开发者信息，点击iOS Development 后面的create ，然后稍等片刻，直到create按钮变成灰色或者变成Reset(或者变没了)。<br> <img src="http://7xv28v.com1.z0.glb.clouddn.com/%E5%85%8D%E8%AF%81%E4%B9%A6%E8%B0%83%E8%AF%955.png" alt="图5"></p></li><li><p>到了这里基本上已经结束。<br>开始真机测试：打开需要真机测试的项目插上手机（Xcode第一次链接手机会很慢，可以选择Xcode菜单栏中的window-&gt;devices查看手机是否准备就绪了），选择项目文件-&gt; General - &gt; Team -&gt; 选择你属于你的Apple ID ，再点击Team 下面的fix issue修复Team 正下方的警告。</p></li><li><p>最后一个问题，你最终会发现Xcode会弹出一个框（process launch failed: Security），这里需要打开你手机的设置-&gt;通用- &gt; 描述文件-&gt; 选择你的Apple ID - &gt; 点击信任 - &gt; 打完收工！</p></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>然后你就可以享受免证书真机调试的福利了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Xcode7正式发布的日子里，苹果给开发者带来了一次惊天的变化，从此开发者不需要花99刀购买开发者证书就能够进行真机调试了，当然如果想要发布到App store那肯定是需要购买的。但是这对于正在学习阶段或者想做一个属于自己APP的同学来说，已经是丰厚的福利了。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSString为什么使用copy,而不使用retain?</title>
    <link href="http://example.com/post/ba545077.html"/>
    <id>http://example.com/post/ba545077.html</id>
    <published>2015-01-10T14:09:17.000Z</published>
    <updated>2023-12-02T10:27:22.183Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="一、原因"><a href="#一、原因" class="headerlink" title="一、原因"></a>一、原因</h1><h2 id="1-1-一方面"><a href="#1-1-一方面" class="headerlink" title="1.1 一方面"></a>1.1 一方面</h2><p>如果使用retain，只是引用计数 +1，并没有生成新的对象，所以效率好。</p><h2 id="1-2-另一方面"><a href="#1-2-另一方面" class="headerlink" title="1.2 另一方面"></a>1.2 另一方面</h2><p>但是使用copy安全。因为NSString为NSMutableString 的基类，如果将NSMutableString 以retain的形式赋值给NSString后，后续修改NSMutableString会导致NSString内容的变化，这通常不是我们希望的，所以NSString要使用copy。比如：</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *mName = [NSMutableString stringWithString:@&quot;li&quot;];  </span><br><span class="line">Person *p = [[[Person alloc] init] autorelease];  </span><br><span class="line">p.name = mName;  </span><br><span class="line">[mName setString:@&quot;zhang&quot;];  </span><br><span class="line">NSLog(@&quot;p.name:%@&quot;, p.name); </span><br></pre></td></tr></table></figure>    </code></pre><span id="more"></span><p>我们把mName的值 “li” 赋给了p.name，而如果p里面的name使用的是retain，那么只是将mName的引用计数+1，这时候p.name的值是 ”li“</p><p>紧接着我们在下面把mName的值设置为“zhang”，结果你再打印p.name，这时候它的值也会变成zhang，这是我们不想见到的。</p><p>使用copy就不会有这个问题。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;

&lt;h1 id=&quot;一、原因&quot;&gt;&lt;a href=&quot;#一、原因&quot; class=&quot;headerlink&quot; title=&quot;一、原因&quot;&gt;&lt;/a&gt;一、原因&lt;/h1&gt;&lt;h2 id=&quot;1-1-一方面&quot;&gt;&lt;a href=&quot;#1-1-一方面&quot; class=&quot;headerlink&quot; title=&quot;1.1 一方面&quot;&gt;&lt;/a&gt;1.1 一方面&lt;/h2&gt;&lt;p&gt;如果使用retain，只是引用计数 +1，并没有生成新的对象，所以效率好。&lt;/p&gt;
&lt;h2 id=&quot;1-2-另一方面&quot;&gt;&lt;a href=&quot;#1-2-另一方面&quot; class=&quot;headerlink&quot; title=&quot;1.2 另一方面&quot;&gt;&lt;/a&gt;1.2 另一方面&lt;/h2&gt;&lt;p&gt;但是使用copy安全。因为NSString为NSMutableString 的基类，如果将NSMutableString 以retain的形式赋值给NSString后，后续修改NSMutableString会导致NSString内容的变化，这通常不是我们希望的，所以NSString要使用copy。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableString *mName = [NSMutableString stringWithString:@&amp;quot;li&amp;quot;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person *p = [[[Person alloc] init] autorelease];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p.name = mName;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[mName setString:@&amp;quot;zhang&amp;quot;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;p.name:%@&amp;quot;, p.name); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="iOS Tips" scheme="http://example.com/categories/iOS-Tips/"/>
    
    
    <category term="NSString、copy" scheme="http://example.com/tags/NSString%E3%80%81copy/"/>
    
  </entry>
  
</feed>
